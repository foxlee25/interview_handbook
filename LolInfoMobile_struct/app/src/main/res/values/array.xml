<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="titles">
        <item>Algorithm</item>
        <item>Android</item>
        <item>IOS</item>
        <item>JAVA</item>
        <item>C++</item>
        <item>Ruby</item>
        <item>WEB</item>
        <item>HTML</item>
        <item>PERL</item>
        <item>C</item>
        <item>SWIFT</item>
    </string-array>

    <string-array name="java">
        <item>General Questions</item>
        <item>Java Threads</item>
        <item>Java Collections</item>
        <item>Garbage Collectors</item>
        <item>Exception Handling</item>
        <item>Java Applets</item>
        <item>Swing</item>
        <item>JDBC</item>
        <item>Remote Method Invocation</item>
        <item>Servlets</item>
        <item>JSP</item>
    </string-array>

    <string-array name="android">
        <item>Android Basics</item>
        <item>Activity</item>
        <item>Fragment</item>
        <item>Intent</item>
        <item>Services</item>
        <item>SQLite database</item>
        <item>UI</item>
        <item>Http and Webservers</item>
    </string-array>

    <string-array name="database">
        <item>DBMS</item>
        <item>Prime and Foreign Key</item>
    </string-array>

    <!--<item>Table</item>-->
    <!--<item>Locks</item>-->
    <!--<item>Key</item>-->
    <!--<item>Statement</item>-->

    <string-array name="dbms">
        <item>What is DBMS</item>
        <item>Various kinds of interactions catered by DBMS</item>
        <item>Advantages of DBMS</item>
    </string-array>

    <string-array name="prime_and_foreign_key">
        <item>Super primary candidate and foreign keys</item>
        <item>Primary key and unique constraints</item>
        <item>Relationships of database</item>
    </string-array>

    <string-array name="what_is_dbms_">
        <item name = "definition"> What is DBMS?</item>
        <item name = "code">
            Database Management Systems (DBMS) are applications designed especially which enable user interaction with other applications.
        </item>
    </string-array>
    <string-array name="various_kinds_of_interactions_catered_by_dbms_">
        <item name = "definition"> What are Various kinds of interactions catered by DBMS?</item>
        <item name = "code">
    \n– Data definition
    \n– Update
    \n– Retrieval
    \n– Administration
        </item>
    </string-array>
    <string-array name="advantages_of_dbms_">
        <item name = "definition">What are advantages of DBMS over traditional file based systems?</item>
        <item name = "code">Database management systems were developed to handle the following difﬁculties of typical ﬁle-processing systems supported by conventional operating systems.
        \n 1. Data redundancy and inconsistency
        \n 2. Difﬁculty in accessing data
        \n 3. Data isolation – multiple ﬁles and formats
        \n 4. Integrity problems
        \n 5. Atomicity of updates
        \n 6. Concurrent access by multiple users
        \n 7. Security problems
        </item>
    </string-array>
    <string-array name="super_primary_candidate_and_foreign_keys_">
        <item name = "definition">What are super, primary, candidate and foreign keys?</item>
        <item name = "code">A superkey is a set of attributes of a relation schema upon which all attributes of the schema are functionally dependent. No two rows can have the same value of super key attributes.
            A Candidate key is minimal superkey, i.e., no proper subset of Candidate key attributes can be a superkey.
            A Primary Key is one of the candidate keys. One of the candidate keys is selected as most important and becomes the primary key. There cannot be more that one primary keys in a table.
            Foreign key is a field (or collection of fields) in one table that uniquely identifies a row of another table. See this for an example.
        </item>
    </string-array>

    <string-array name="primary_key_and_unique_constraints_">
        <item name = "definition">What is the difference between primary key and unique constraints?</item>
        <item name = "code">A superkey is a set of attributes of a relation schema upon which all attributes of the schema are functionally dependent. No two rows can have the same value of super key attributes.
            Primary key cannot have NULL value, the unique constraints can have NULL values. There is only one primary key in a table, but there can be multiple unique constrains.
        </item>
    </string-array>
    <string-array name="relationships_of_database_">
        <item name = "definition"> Enlist the various relationships of database.</item>
        <item name = "code">A superkey is a set of attributes of a relation schema upon which all attributes of the schema are functionally dependent. No two rows can have the same value of super key attributes.
            The various relationships of database are:
        \n    One-to-one: Single table having drawn relationship with another table having similar kind of columns.
        \n    One-to-many: Two tables having primary and foreign key relation.
        \n    Many-to-many: Junction table having many tables related to many tables.
        </item>
    </string-array>

    <string-array name="android_basics">
        <item>Android Architecture</item>
        <item>ANR</item>
    </string-array>
    <string-array name="activity">
        <item>Activity</item>
        <item>Activity Life Cycle</item>
    </string-array>
    <string-array name="fragment">
        <item>Fragment Life Cycle</item>
    </string-array>
    <string-array name="intent">
        <item>Intent</item>
        <item>Intent Filter</item>
    </string-array>
    <string-array name="services">
        <item>Differentiate Activities</item>
    </string-array>
    <string-array name="sqlite_database">
        <item>SQLite Helper</item>
        <item>Cursor</item>
    </string-array>
    <string-array name="ui">
        <item>Weight</item>
        <item>Recyclerview</item>
    </string-array>
    <string-array name="http_and_webservers">
        <item>Send Email</item>
        <item>Http Post</item>
    </string-array>

    <string-array name="android_architecture_">
        <item name = "definition"> What is the Android Architecture?</item>
        <item name = "code">
            Android Architecture is made up of 4 key components:
    \n– Linux Kernel
    \n– Libraries
    \n– Android Framework
    \n– Android Applications
        </item>
    </string-array>
    <string-array name="anr_">
        <item name = "definition"> What is ANR ?</item>
        <item name = "code">
            An ANR happens when some long operation takes place in the "main" thread. This is the event loop thread, and if it is busy,
            Android cannot process any further GUI events in the application, and thus throws up an ANR dialog.
        </item>
    </string-array>

    <string-array name="activity_">
        <item name = "definition">Describe Activities.</item>
        <item name = "code">
            Activities are what you refer to as the window to a user interface. Just as you create windows in order to display
            output or to ask for an input in the form of dialog boxes, activities play the same role, though it may not always be in the form of a user interface.
        </item>
    </string-array>
    <string-array name="activity_life_cycle_">
        <item name = "definition"> What is Activity life cycle?</item>
        <item name = "code">
            To create an activity, you must create a subclass of Activity (or an existing subclass of it). In your subclass, you need to implement callback methods
            that the system calls when the activity transitions between various states of its lifecycle, such as when the activity is being created, stopped,
            resumed, or destroyed.onCreate() onRestart() onStart() onResume() onPause() onStop() onDestroy()
        </item>
    </string-array>

    <string-array name="fragment_life_cycle_">
        <item name = "definition"> What is Fragment life cycle?</item>
        <item name = "code">
            \n onAttach()The fragment instance is associated with an activity instance.The fragment and the activity is not fully initialized. Typically you get in this method a reference to the activity which uses the fragment for further initialization work.
            \n onCreate() The system calls this method when creating the fragment. You should initialize essential components of the fragment that you want to retain when the fragment is paused or stopped, then resumed.
            \n onCreateView() The system calls this callback when it\'s time for the fragment to draw its user interface for the first time. To draw a UI for your fragment, you must return a View component from this method that is the root of your fragment\'s layout. You can return null if the fragment does not provide a UI.
            \n onActivityCreated()The onActivityCreated() is called after the onCreateView() method when the host activity is created. Activity and fragment instance have been created as well as the view hierarchy of the activity. At this point, view can be accessed with the findViewById() method. example. In this method you can instantiate objects which require a Context object
            \n onStart()The onStart() method is called once the fragment gets visible.
            \n onResume()Fragment becomes active.
            \n onPause() The system calls this method as the first indication that the user is leaving the fragment. This is usually where you should commit any changes that should be persisted beyond the current user session.
            \n onStop()Fragment going to be stopped by calling onStop()
            \n onDestroyView()Fragment view will destroy after call this method
            \n onDestroy()onDestroy() called to do final clean up of the fragment\'s state but Not guaranteed to be called by the Android platform.
        </item>
    </string-array>

    <string-array name="intent_">
        <item name = "definition"> What are Intents?</item>
        <item name = "code">
            Intents displays notification messages to the user from within the Android enabled device. It can be used to alert the user of a
            particular state that occurred. Users can be made to respond to intents.
        </item>
    </string-array>

    <string-array name="intent_filter_">
        <item name = "definition">What is the function of an intent filter?</item>
        <item name = "code">
            Because every component needs to indicate which intents they can respond to,
            intent filters are used to filter out intents that these components are willing to receive.
            One or more intent filters are possible, depending on the services and activities that is going to make use of it.
        </item>
    </string-array>

    <string-array name="differentiate_activities_">
        <item name = "definition">Differentiate Activities from Services.</item>
        <item name = "code">
            Activities can be closed, or terminated anytime the user wishes. On the other hand, services are designed to run behind the scenes, and can act
            independently. Most services run continuously, regardless of whether there are certain or no activities being executed.
        </item>
    </string-array>

    <string-array name="sqlite_helper_">
        <item name = "definition">What is the use of SQLite open helper class in SQLite?</item>
        <item name = "code">
            A helper class allow database management, creation and version management. This is the class where we will create all the tables, and
            upgrade tables.
        </item>
    </string-array>
    <string-array name="cursor_">
        <item name = "definition">How to show SQLite Database table information in android application?</item>
        <item name = "code">
            Showing database information will be better suited with table layout since table layout is not an adapter view, you can\'t use cursor adapter with it.
            So use table layout with cursor to show data table information.
        </item>
    </string-array>

    <string-array name="weight_">
        <item name = "definition">Where do we defineweight sum and write them?</item>
        <item name = "code">
            weight property says how much portion of remaining space has to be taken by this view. weight sum says sum of its child view\'s weights.
            If weight sum is not provided to the layout, then it will be automatically calculated by summing the weight of child views in that layout.
            Use weight sum in the layout only if you are not going to add a new child view to your layout. It may create problem if you want to modify
            or add a new child view with a new weight to your existing layout. Then again you have to make sure that you modify the parent layout\'s
            weight sum as well. Else it will not work as desired.
        </item>
    </string-array>
    <string-array name="recyclerview_">
        <item name = "definition">What is the difference between RecyclerView and ListView</item>
        <item name = "code">
            1) ViewHolder Pattern\n
            In a ListView, it was recommended to use the ViewHolder pattern but it was never a compulsion. In case of RecyclerView, this is mandatory using the RecyclerView.ViewHolderclass. This is one of the major differences between the ListView and the RecyclerView.
            It makes things a bit more complex in RecyclerView but a lot of problems that we faced in the ListView are solved efficiently.\n
            2) LayoutManager\n
            This is another massive enhancement brought to the RecyclerView. In a ListView, the only type of view available is the vertical ListView. There is no official way to even implement a horizontal ListView.
            Now using a RecyclerView, we can have a\n
            i) LinearLayoutManager - which supports both vertical and horizontal lists,\n
            ii) StaggeredLayoutManager - which supports Pinterest like staggered lists,\n
            iii) GridLayoutManager - which supports displaying grids as seen in Gallery apps.\n
            And the best thing is that we can do all these dynamically as we want.\n
            3) Item Animator\n
            ListViews are lacking in support of good animations, but the RecyclerView brings a whole new dimension to it. Using the RecyclerView.ItemAnimator class, animating the views becomes so much easy and intuitive.
            \n
            4) Item Decoration\n
            In case of ListViews, dynamically decorating items like adding borders or dividers was never easy. But in case of RecyclerView, the RecyclerView.ItemDecorator class gives huge control to the developers but makes things a bit more time consuming and complex.
            \n
            5) OnItemTouchListener\n
            Intercepting item clicks on a ListView was simple, thanks to itsAdapterView.OnItemClickListener interface. But the RecyclerView gives much more power and control to its developers by the RecyclerView.OnItemTouchListener but it complicates things a bit for the developer.
        </item>
    </string-array>

    <string-array name="send_email_">
        <item name = "definition">How to Send Email using intent?</item>
        <item name = "code">
           Intent email = new Intent(Intent.ACTION_SEND); \n
            email.setType("message/rfc822"); \n
            email.putExtra(Intent.EXTRA_EMAIL, \n
            new String[] {"info@skillgun.com"}); \n
            email.putExtra(Intent.EXTRA_SUBJECT, "Hi, This is a test mail.."); \n
            startActivity(Intent.createChooser(email, "Choose an Email Client"));\n
        </item>
    </string-array>
    <string-array name="http_post_">
        <item name = "definition">How to excute HTTP POST Request?</item>
        <item name = "code">
            HTTP Post is part of a deprecated HTTP classes like org.apache.http and AndroidHttpClient as of Android 5.1.[1] Migrate your code to the
            HttpURLConnection classes which includes Posting functionality. HTTP Post is used in Java to request that a specific web server receive
            and store data submitted within a request form. The data is submitted and stored in name-value pairs. Examples of pairs include:
            email-your email address; username-your username; and password-your password.
        </item>
    </string-array>

    <string-array name="general_questions">
        <item>JVM</item>
        <item>JRE</item>
        <item>Static keyword</item>
        <item>Access non static variable</item>
        <item>Data Types</item>
        <item>Overriding and Overloading</item>
        <item>Constructor</item>
        <item>Inheritance</item>
        <item>Interface and an Abstract class</item>
        <item>Pass by reference and pass by value</item>
    </string-array>

    <string-array name="java_threads">
        <item>Processes and threads</item>
        <item>Ways of creating a thread</item>
        <item>Available thread states</item>
        <item>Synchronized method</item>
        <item>Thread synchronization</item>
        <item>Deadlock</item>
        <item>Threads can access without deadlock</item>
    </string-array>

    <string-array name="java_collections">
        <item>Java Collections Framework</item>
        <item>Cloneable and Serializable Interfaces</item>
        <item>Iterator</item>
        <item>Iterator and ListIterator</item>
        <item>Fail fast and fail safe</item>
        <item>HashMap</item>
        <item>HashCode</item>
        <item>HashMap and Hashtable</item>
        <item>Array and ArrayList</item>
        <item>ArrayList and LinkedList</item>
        <item>Comparable and Comparator interface</item>
        <item>Java Priority Queue</item>
        <item>Big O notation</item>
        <item>Unordered array</item>
        <item>Enumeration and Iterator interfaces</item>
        <item>Java Collection framework</item>
        <item>HashSet and TreeSet</item>
    </string-array>

    <string-array name="garbage_collectors">
        <item>Purpose of garbage collection</item>
        <item>System and Runtime</item>
        <item>Finalization</item>
        <item>Object reference</item>
        <item>Java Heap</item>
        <item>Serial and Throughput Garbage</item>
        <item>Garbage Collection</item>
        <item>Permanent Generation Space</item>
    </string-array>

    <string-array name="exception_handling">
        <item>Exceptions in Java</item>
        <item>Exception and Error</item>
        <item>throw and throws</item>
        <item>finally block</item>
        <item>Exception object</item>
        <item>finalize block</item>
    </string-array>

    <string-array name="java_applets">
        <item>What is an Applet</item>
        <item>Life cycle of an Applet</item>
        <item>applet is loaded</item>
        <item>Applet and a Java Application</item>
        <item>Restrictions imposed on Java applets</item>
        <item>Untrusted applets</item>
        <item>Applets loaded</item>
        <item>Applet class loader</item>
        <item>Applet security manager</item>
    </string-array>

    <string-array name="swing">
        <item>Choice and a List</item>
        <item>Layout manager</item>
        <item>Scrollbar</item>
        <item>Threadsafe</item>
        <item>Component subclasses</item>
        <item>Clipping</item>
        <item>MenuItem and a CheckboxMenuItem</item>
        <item>BorderLayout</item>
        <item>GridBagLayout</item>
        <item>Window and a Frame</item>
        <item>Clipping and repainting</item>
        <item>Event listener</item>
        <item>GUI component</item>
        <item>Traditional windowing systems</item>
        <item>Design pattern</item>
    </string-array>

    <string-array name="jdbc">
        <item>What is JDBC</item>
        <item>Driver in JDBC</item>
        <item>Class forName</item>
        <item>Prepared Statement</item>
        <item>CallableStatement</item>
        <item>Connection pooling</item>
    </string-array>

    <string-array name="remote_method_invocation">
        <item>What is RMI</item>
        <item>Basic principle of RMI</item>
        <item>RMI Architecture</item>
        <item>Remote Interface in RMI</item>
        <item>Java Rmi Naming Class</item>
        <item>Binding in RMI</item>
        <item>Bind and Rebind Methods of Naming Class</item>
        <item>Steps involved to make work a RMI program</item>
        <item>Role of Stub</item>
        <item>DGC</item>
        <item>Marshalling and Demarshalling</item>
        <item>Serialization and Deserialization</item>
    </string-array>

    <string-array name="servlets">
        <item>What is a Servlet</item>
        <item>Architechure of a Servlet</item>
        <item>Applet and a Servlet</item>
        <item>GenericServlet and HttpServlet</item>
        <item>Life Cycle of a Servlet</item>
        <item>doGet and doPost</item>
        <item>Web Application</item>
        <item>Server Side Include</item>
        <item>Servlet Chaining</item>
        <item>Client Machine</item>
        <item>Structure of the HTTP response</item>
        <item>Session and Cookie</item>
        <item>Browser and Servlet</item>
        <item>HTTP Tunneling</item>
        <item>SendRedirect and Forward Methods</item>
        <item>URL Encoding and URL Decoding</item>
    </string-array>

    <string-array name="jsp">
        <item>JSP Page</item>
        <item>JSP requests handled</item>
        <item>Advantages of JSP</item>
        <item>Directives Available in JSP</item>
        <item>JSP Actions</item>
        <item>Scriptlets</item>
        <item>Decalarations</item>
        <item>Expressions</item>
        <item>Implicit Objects</item>
    </string-array>

    <!--<string-array name="general_questions">-->
    <string-array name="jvm_">
        <item name = "definition"> What is JVM ? Why is Java called the “Platform Independent Programming Language” ?</item>
        <item name = "code">
            A Java virtual machine (JVM) is a process virtual machine that can execute Java bytecode. Each Java source file is compiled into a bytecode file,
            which is executed by the JVM. Java was designed to allow application programs to be built that could be run on any platform, without having to
            be rewritten or recompiled by the programmer for each separate platform. A Java virtual machine makes this possible, because it is aware of the
            specific instruction lengths and other particularities of the underlying hardware platform.
        </item>
    </string-array>

    <string-array name="jre_">
        <item name = "definition"> What is the Difference between JDK and JRE ?</item>
        <item name = "code">
            The Java Runtime Environment (JRE) is basically the Java Virtual Machine (JVM) where your Java programs are being executed. It also includes
            browser plugins for applet execution. The Java Development Kit (JDK) is the full featured Software Development Kit for Java, including the JRE,
            the compilers and tools (like JavaDoc, and Java Debugger), in order for a user to develop, compile and execute Java applications.
        </item>
    </string-array>

    <string-array name="static_keyword_">
        <item name = "definition">What does the “static” keyword mean ? Can you override private or static method in Java ?</item>
        <item name = "code">
            The static keyword denotes that a member variable or method can be accessed, without requiring an instantiation of the class to which it belongs.
            A user cannot override static methods in Java, because method overriding is based upon dynamic binding at runtime and static methods are statically
            binded at compile time. A static method is not associated with any instance of a class so the concept is not applicable.
        </item>
    </string-array>

    <string-array name="access_non_static_variable_">
        <item name = "definition">Can you access non static variable in static context ?</item>
        <item name = "code">
            A static variable in Java belongs to its class and its value remains the same for all its instances. A static variable is initialized when the class
            is loaded by the JVM. If your code tries to access a non-static variable, without any instance, the compiler will complain, because those variables
            are not created yet and they are not associated with any instance.
        </item>
    </string-array>

    <string-array name="data_types_">
        <item name = "definition">What are the Data Types supported by Java ? What is Autoboxing and Unboxing ?</item>
        <item name = "code">
            The eight primitive data types supported by the Java programming language are:
            byte\n
            short\n
            int\n
            long\n
            float\n
            double\n
            boolean\n
            char\n
            Autoboxing is the automatic conversion made by the Java compiler between the primitive types and their corresponding object wrapper classes.
            For example, the compiler converts an int to an Integer, a double to a Double, and so on. If the conversion goes the other way, this operation
            is called unboxing.
        </item>
    </string-array>

    <string-array name="overriding_and_overloading_">
        <item name = "definition"> What is Function Overriding and Overloading in Java ?</item>
        <item name = "code">
            Method overloading in Java occurs when two or more methods in the same class have the exact same name, but different parameters.
            On the other hand, method overriding is defined as the case when a child class redefines the same method as a parent class.
            Overridden methods must have the same name, argument list, and return type. The overriding method may not limit the access of the method it override
        </item>
    </string-array>

    <string-array name="constructor_">
        <item name = "definition"> What is a Constructor, Constructor Overloading in Java and Copy Constructor ?</item>
        <item name = "code">
            The Java Runtime Environment (JRE) is basically the Java Virtual Machine (JVM) where your Java programs are being executed. It also includes
            browser plugins for applet execution. The Java Development Kit (JDK) is the full featured Software Development Kit for Java, including the JRE,
            the compilers and tools (like JavaDoc, and Java Debugger), in order for a user to develop, compile and execute Java applications.
        </item>
    </string-array>

    <string-array name="inheritance_">
        <item name = "definition">Does Java support multiple inheritance ?</item>
        <item name = "code">
            No, Java does not support multiple inheritance. Each class is able to extend only on one class, but is able to implement more than one interfaces.
        </item>
    </string-array>

    <string-array name="interface_and_an_abstract_class_">
        <item name = "definition"> What is the Difference between JDK and JRE ?</item>
        <item name = "code">
            Java provides and supports the creation both of abstract classes and interfaces.
            Both implementations share some common characteristics, but they differ in the following features:\n
            All methods in an interface are implicitly abstract. On the other hand, an abstract class may contain both abstract and non-abstract methods.\n
            A class may implement a number of Interfaces, but can extend only one abstract class.\n
            In order for a class to implement an interface, it must implement all its declared methods. However, a class may not implement all declared
            methods of an abstract class. Though, in this case, the sub-class must also be declared as abstract.\n
            Abstract classes can implement interfaces without even providing the implementation of interface methods.\n
            Variables declared in a Java interface is by default final. An abstract class may contain non-final variables.\n
            Members of a Java interface are public by default. A member of an abstract class can either be private, protected or public.\n
            An interface is absolutely abstract and cannot be instantiated. An abstract class also cannot be instantiated, but can be invoked if it contains a main method.
        </item>
    </string-array>

    <string-array name="pass_by_reference_and_pass_by_value_">
        <item name = "definition"> What are pass by reference and pass by value ?</item>
        <item name = "code">
            When an object is passed by value, this means that a copy of the object is passed. Thus, even if changes are made to that object, it doesn’t affect
            the original value. When an object is passed by reference, this means that the actual object is not passed, rather a reference of the object is passed.
            Thus, any changes made by the external method, are also reflected in all places.
        </item>
    </string-array>

    <!--<string-array name="java_threads">-->
    <string-array name="processes_and_threads_">
        <item name = "definition"> What is the difference between processes and threads ?</item>
        <item name = "code">
            A process is an execution of a program, while a Thread is a single execution sequence within a process.
            A process can contain multiple threads. A Thread is sometimes called a lightweight process.
        </item>
    </string-array>

    <string-array name="ways_of_creating_a_thread_">
        <item name = "definition"> Explain different ways of creating a thread. Which one would you prefer and why ?</item>
        <item name = "code">
            There are three ways that can be used in order for a Thread to be created:\n
            A class may extend the Thread class.\n
            A class may implement the Runnable interface.\n
            An application can use the Executor framework, in order to create a thread pool.\n
            The Runnable interface is preferred, as it does not require an object to inherit the Thread class. In case your application
            design requires multiple inheritance, only interfaces can help you. Also, the thread pool is very efficient and can be implemented and used very easily.
        </item>
    </string-array>

    <string-array name="available_thread_states_">
        <item name = "definition">Explain the available thread states in a high\-level</item>
        <item name = "code">
            During its execution, a thread can reside in one of the following states:
            NEW: The thread becomes ready to run, but does not necessarily start running immediately.\n
            RUNNABLE: The Java Virtual Machine \(JVM\) is actively executing the thread’s code.\n
            BLOCKED: The thread is in a blocked state while waiting for a monitor lock.\n
            WAITING: The thread waits for another thread to perform a particular action.\n
            TIMED_WAITING: The thread waits for another thread to perform a particular action up to a specified waiting time.\n
            TERMINATED: The thread has finished its execution.
        </item>
    </string-array>

    <string-array name="synchronized_method_">
        <item name = "definition">What is the difference between a synchronized method and a synchronized block ?</item>
        <item name = "code">
            In Java programming, each object has a lock. A thread can acquire the lock for an object by using the synchronized keyword.
            The synchronized keyword can be applied in a method level \(coarse grained lock\) or block level of code \(fine grained lock\).
        </item>
    </string-array>

    <string-array name="thread_synchronization_">
        <item name = "definition">How does thread synchronization occurs inside a monitor ? What levels of synchronization can you apply ?</item>
        <item name = "code">
            The JVM uses locks in conjunction with monitors. A monitor is basically a guardian that watches over a sequence of synchronized code and
            ensuring that only one thread at a time executes a synchronized piece of code. Each monitor is associated with an object reference.
            The thread is not allowed to execute the code until it obtains the lock.
        </item>
    </string-array>

    <string-array name="deadlock_">
        <item name = "definition">What’s a deadlock ?</item>
        <item name = "code">
            A condition that occurs when two processes are waiting for each other to complete, before proceeding. The result is that both processes wait endlessly.
        </item>
    </string-array>

    <string-array name="threads_can_access_without_deadlock_">
        <item name = "definition">How do you ensure that N threads can access N resources without deadlock ?</item>
        <item name = "code">
            A very simple way to avoid deadlock while using N threads is to impose an ordering on the locks and force each thread to follow that ordering.
            Thus, if all threads lock and unlock the mutexes in the same order, no deadlocks can arise.
        </item>
    </string-array>

    <string-array name="java_collections_framework_">
        <item name = "definition"> Explain different ways of creating a thread. Which one would you prefer and why ?</item>
        <item name = "code">
            There are three ways that can be used in order for a Thread to be created:\n
            A class may extend the Thread class.\n
            A class may implement the Runnable interface.\n
            An application can use the Executor framework, in order to create a thread pool.
        </item>
    </string-array>

    <string-array name="cloneable_and_serializable_interfaces_">
        <item name = "definition"> Explain different ways of creating a thread. Which one would you prefer and why ?</item>
        <item name = "code">
            The Collection interface specifies groups of objects known as elements. Each concrete implementation of a Collection
            can choose its own way of how to maintain and order its elements. Some collections allow duplicate keys, while some
            other collections don’t. The semantics and the implications of either cloning or serialization come into play when
            dealing with actual implementations. Thus, the concrete implementations of collections should decide how they can be cloned or serialized.
        </item>
    </string-array>

    <string-array name="iterator_">
        <item name = "definition">What is an Iterator ?</item>
        <item name = "code">
            The Iterator interface provides a number of methods that are able to iterate over any Collection. Each Java Collection contains the
            iterator method that returns an Iterator instance. Iterators are capable of removing elements from the underlying collection during the iteration.
        </item>
    </string-array>

    <string-array name="iterator_and_listiterator_">
        <item name = "definition">What differences exist between Iterator and ListIterator ?</item>
        <item name = "code">
            The differences of these elements are listed below:\n
            An Iterator can be used to traverse the Set and List collections, while the ListIterator can be used to iterate only over Lists.\n
            The Iterator can traverse a collection only in forward direction, while the ListIterator can traverse a List in both directions.\n
            The ListIterator implements the Iterator interface and contains extra functionality, such as adding an element, replacing an element,\n
            getting the index position for previous and next elements, etc.
        </item>
    </string-array>

    <string-array name="fail_fast_and_fail_safe_">
        <item name = "definition">What is difference between fail fast and fail  safe ?</item>
        <item name = "code">
            The Iterator\'s fail  safe property works with the clone of the underlying collection and thus, it is not affected by any
            modification in the collection. All the collection classes in java.util package are fail  fast, while the collection classes
            in java.util.concurrent are fail  safe. Fail fast iterators throw a ConcurrentModificationException, while fail  safe iterator
            never throws such an exception.
        </item>
    </string-array>

    <string-array name="hashmap_">
        <item name = "definition">How HashMap works in Java ?</item>
        <item name = "code">
            A HashMap in Java stores key-value pairs. The HashMap requires a hash function and uses hashCode and equals methods, in order
            to put and retrieve elements to and from the collection respectively. When the put method is invoked, the HashMap calculates
            the hash value of the key and stores the pair in the appropriate index inside the collection. If the key exists, its value is
            updated with the new value. Some important characteristics of a HashMap are its capacity, its load factor and the threshold resizing.
        </item>
    </string-array>

    <string-array name="hashcode_">
        <item name = "definition">What is the importance of hashCode() and equals() methods ?</item>
        <item name = "code">
            In Java, a HashMap uses the hashCode and equals methods to determine the index of the key-value pair and to detect duplicates. More specifically,
            the hashCode method is used in order to determine where the specified key will be stored. Since different keys may produce the same hash value,
            the equals method is used, in order to determine whether the specified key actually exists in the collection or not. Therefore, the implementation
            of both methods is crucial to the accuracy and efficiency of the HashMap.
        </item>
    </string-array>

    <string-array name="hashmap_and_hashtable_">
        <item name = "definition">What differences exist between HashMap and Hashtable ?</item>
        <item name = "code">
            Both the HashMap and Hashtable classes implement the Map interface and thus, have very similar characteristics. However,
            they differ in the following features:
            A HashMap allows the existence of null keys and values, while a Hashtable doesn’t allow neither null keys, nor null values.\n
            A Hashtable is synchronized, while a HashMap is not. Thus, HashMap is preferred in single-threaded environments, while a Hashtable
            is suitable for multi-threaded environments.\n
            A HashMap provides its set of keys and a Java application can iterate over them. Thus, a HashMap is fail-fast. On the other hand,
            a Hashtable provides an Enumeration of its keys.\n
            The Hashtable class is considered to be a legacy class.
        </item>
    </string-array>

    <string-array name="array_and_arraylist_">
        <item name = "definition">What differences exist between HashMap and Hashtable ?</item>
        <item name = "code">
            The Array and ArrayList classes differ on the following features:
            Arrays can contain primitive or objects, while an ArrayList can contain only objects.
            Arrays have fixed size, while an ArrayList is dynamic.
            An ArrayListprovides more methods and features, such as addAll, removeAll, iterator, etc.
            For a list of primitive data types, the collections use autoboxing to reduce the coding effort. However, this approach
        </item>
    </string-array>

    <string-array name="arraylist_and_linkedlist_">
        <item name = "definition">What is difference between ArrayList and LinkedList ? </item>
        <item name = "code">
            Both the ArrayList and LinkedList classes implement the List interface, but they differ on the following features:
            An ArrayList is an index based data structure backed by an Array. It provides random access to its elements with a performance equal to O\(1\).\n
            On the other hand, a LinkedList stores its data as list of elements and every element is linked to its previous and next element.\n
            In this case, the search operation for an element has execution time equal to O\(n\).\n
            The Insertion, addition and removal operations of an element are faster in a LinkedList compared to an ArrayList, because there is no need of
            resizing an array or updating the index when an element is added in some arbitrary position inside the collection.\n
            A LinkedList consumes more memory than an ArrayList, because every node in a LinkedList stores two references, one for its previous element
            and one for its next element.\n
            Check also our article ArrayList vs. LinkedList.
        </item>
    </string-array>

    <string-array name="comparable_and_comparator_interface_">
        <item name = "definition">What is Comparable and Comparator interface ? List their differences.</item>
        <item name = "code">
            Java provides the Comparable interface, which contains only one method, called compareTo. This method compares two objects, in order to
            impose an order between them. Specifically, it returns a negative integer, zero, or a positive integer to indicate that the input object
            is less than, equal or greater than the existing object. Java provides the Comparator interface, which contains two methods, called compare
            and equals. The first method compares its two input arguments and imposes an order between them. It returns a negative integer, zero, or a
            positive integer to indicate that the first argument is less than, equal to, or greater than the second. The second method requires an object
            as a parameter and aims to decide whether the input object is equal to the comparator. The method returns true, only if the specified object
            is also a comparator and it imposes the same ordering as the comparator.
        </item>
    </string-array>

    <string-array name="java_priority_queue_">
        <item name = "definition"> What are pass by reference and pass by value ?</item>
        <item name = "code">
            The PriorityQueue is an unbounded queue, based on a priority heap and its elements are ordered in their natural order. At the time of its creation,
            we can provide a Comparator that is responsible for ordering the elements of the PriorityQueue. A PriorityQueue doesn’t allow null values, those objects that doesn’t provide natural ordering, or those objects that don’t have any comparator associated with them. Finally, the Java PriorityQueue is not thread-safe and it requires O(log(n)) time for its enqueing and dequeing operations.
        </item>
    </string-array>

    <string-array name="big_o_notation_">
        <item name = "definition">What do you know about the big O notation and can you give some examples with respect to different data structures ?</item>
        <item name = "code">
            The Big-O notation simply describes how well an algorithm scales or performs in the worst case scenario as the number of elements in a data structure increases. The Big-O notation can also be used to describe other behavior such as memory consumption. Since the collection classes are actually data structures, we usually use the Big-O notation to chose the best implementation to use, based on time, memory and performance. Big-O notation can give a good indication about performance for large amounts of data.
        </item>
    </string-array>

    <string-array name="unordered_array_">
        <item name = "definition">What is the tradeoff between using an unordered array versus an ordered array ?</item>
        <item name = "code">
            The major advantage of an ordered array is that the search times have time complexity of O\(log n\), compared to that of an unordered array, which is O (n). The disadvantage of an ordered array is that the insertion operation has a time complexity of O(n), because the elements with higher values must be moved to make room for the new element. Instead, the insertion operation for an unordered array takes constant time of O\(1\).
        </item>
    </string-array>

    <string-array name="java_collection_framework_">
        <item name = "definition"> What are some of the best practices relating to the Java Collection framework ?</item>
        <item name = "code">
            Choosing the right type of the collection to use, based on the application’s needs, is very crucial for its performance. For example if the size
            of the elements is fixed and know a priori, we shall use an Array, instead of an ArrayList.Some collection classes allow us to specify their initial
            capacity. Thus, if we have an estimation on the number of elements that will be stored, we can use it to avoid rehashing or resizing.Always use
            Generics for type-safety, readability, and robustness. Also, by using Generics you avoid the ClassCastException during runtime.\n
            Use immutable classes provided by the Java Development Kit (JDK) as a key in a Map, in order to avoid the implementation of the hashCode and equals
            methods for our custom class.Program in terms of interface not implementation.Return zero-length collections or arrays as opposed to returning a null
            in case the underlying collection is actually empty.
        </item>
    </string-array>

    <string-array name="enumeration_and_iterator_interfaces_">
        <item name = "definition"> What are some of the best practices relating to the Java Collection framework ?</item>
        <item name = "code">
            Enumeration is twice as fast as compared to an Iterator and uses very less memory. However, the Iterator is much safer compared to Enumeration,
            because other threads are not able to modify the collection object that is currently traversed by the iterator. Also, Iteratorsallow the caller
            to remove elements from the underlying collection, something which is not possible with
        </item>
    </string-array>

    <string-array name="hashset_and_treeset_">
        <item name = "definition"> What is the difference between HashSet and TreeSet ?</item>
        <item name = "code">
            The HashSet is Implemented using a hash table and thus, its elements are not ordered. The add, remove, and contains methods of a HashSet have constant
            time complexity O(1). On the other hand, a TreeSet is implemented using a tree structure. The elements in a TreeSet are sorted, and thus, the add,
            remove, and contains methods have time complexity of O\(logn\).es.
        </item>
    </string-array>

    <!--<string name="next"></string>-->
    <string-array name="java_collections_">
        <item name = "definition"> What is the Difference between JDK and JRE ?</item>
        <item name = "code">
            The Java Runtime Environment (JRE) is basically the Java Virtual Machine (JVM) where your Java programs are being executed. It also includes
            browser plugins for applet execution. The Java Development Kit (JDK) is the full featured Software Development Kit for Java, including the JRE,
            the compilers and tools (like JavaDoc, and Java Debugger), in order for a user to develop, compile and execute Java applications.
        </item>
    </string-array>

    <string-array name="garbage_collectors_">
        <item name = "definition"> What is the Difference between JDK and JRE ?</item>
        <item name = "code">
            The Java Runtime Environment (JRE) is basically the Java Virtual Machine (JVM) where your Java programs are being executed. It also includes
            browser plugins for applet execution. The Java Development Kit (JDK) is the full featured Software Development Kit for Java, including the JRE,
            the compilers and tools (like JavaDoc, and Java Debugger), in order for a user to develop, compile and execute Java applications.
        </item>
    </string-array>

    <string-array name="exception_handling_">
        <item name = "definition"> What is the Difference between JDK and JRE ?</item>
        <item> name = "code">
            The Java Runtime Environment (JRE) is basically the Java Virtual Machine (JVM) where your Java programs are being executed. It also includes
            browser plugins for applet execution. The Java Development Kit (JDK) is the full featured Software Development Kit for Java, including the JRE,
            the compilers and tools (like JavaDoc, and Java Debugger), in order for a user to develop, compile and execute Java applications.
        </item>
    </string-array>

    <string-array name="java_applets_">
        <item name = "definition"> What is the Difference between JDK and JRE ?</item>
        <item name = "code">
            The Java Runtime Environment (JRE) is basically the Java Virtual Machine (JVM) where your Java programs are being executed. It also includes
            browser plugins for applet execution. The Java Development Kit (JDK) is the full featured Software Development Kit for Java, including the JRE,
            the compilers and tools (like JavaDoc, and Java Debugger), in order for a user to develop, compile and execute Java applications.
        </item>
    </string-array>

    <string-array name="swing_">
        <item name = "definition"> What is the Difference between JDK and JRE ?</item>
        <item name = "code">
            The Java Runtime Environment (JRE) is basically the Java Virtual Machine (JVM) where your Java programs are being executed. It also includes
            browser plugins for applet execution. The Java Development Kit (JDK) is the full featured Software Development Kit for Java, including the JRE,
            the compilers and tools (like JavaDoc, and Java Debugger), in order for a user to develop, compile and execute Java applications.
        </item>
    </string-array>

    <string-array name="jdbc_">
        <item name = "definition"> What is the Difference between JDK and JRE ?</item>
        <item name = "code">
            The Java Runtime Environment (JRE) is basically the Java Virtual Machine (JVM) where your Java programs are being executed. It also includes
            browser plugins for applet execution. The Java Development Kit (JDK) is the full featured Software Development Kit for Java, including the JRE,
            the compilers and tools (like JavaDoc, and Java Debugger), in order for a user to develop, compile and execute Java applications.
        </item>
    </string-array>

    <string-array name="remote_method_invocation_">
        <item name = "definition"> What is the Difference between JDK and JRE ?</item>
        <item name = "code">
            The Java Runtime Environment (JRE) is basically the Java Virtual Machine (JVM) where your Java programs are being executed. It also includes
            browser plugins for applet execution. The Java Development Kit (JDK) is the full featured Software Development Kit for Java, including the JRE,
            the compilers and tools (like JavaDoc, and Java Debugger), in order for a user to develop, compile and execute Java applications.
        </item>
    </string-array>

    <string-array name="servlets_">
        <item name = "definition"> What is the Difference between JDK and JRE ?</item>
        <item name = "code">
            The Java Runtime Environment (JRE) is basically the Java Virtual Machine (JVM) where your Java programs are being executed. It also includes
            browser plugins for applet execution. The Java Development Kit (JDK) is the full featured Software Development Kit for Java, including the JRE,
            the compilers and tools (like JavaDoc, and Java Debugger), in order for a user to develop, compile and execute Java applications.
        </item>
    </string-array>

    <string-array name="jsp_">
        <item name = "definition"> What is the Difference between JDK and JRE ?</item>
        <item name = "code">
            The Java Runtime Environment (JRE) is basically the Java Virtual Machine (JVM) where your Java programs are being executed. It also includes
            browser plugins for applet execution. The Java Development Kit (JDK) is the full featured Software Development Kit for Java, including the JRE,
            the compilers and tools (like JavaDoc, and Java Debugger), in order for a user to develop, compile and execute Java applications.
        </item>
    </string-array>

    <string-array name="purpose_of_garbage_collection_">
        <item name = "definition"> Explain different ways of creating a thread. Which one would you prefer and why ?</item>
        <item name = "code">
            The purpose of garbage collection is to identify and discard those objects that are no longer needed by the application,
            in order for the resources to be reclaimed and reused.
        </item>
    </string-array>

    <string-array name="system_and_runtime_">
        <item name = "definition">What does System.gc() and Runtime.gc() methods do ?</item>
        <item name = "code">
            These methods can be used as a hint to the JVM, in order to start a garbage collection. However, this it is up to the Java Virtual
            Machine (JVM) to start the garbage collection immediately or later in time.
        </item>
    </string-array>

    <string-array name="finalization_">
        <item name = "definition">When is the finalize() called ? What is the purpose of finalization ?</item>
        <item name = "code">
            The finalize method is called by the garbage collector, just before releasing the object’s memory. It is normally
            advised to release resources held by the object inside the finalize method.
        </item>
    </string-array>

    <string-array name="object_reference_">
        <item name = "definition">If an object reference is set to null, will the Garbage Collector immediately free the memory held by that object ?</item>
        <item name = "code">
            No, the object will be available for garbage collection in the next cycle of the garbage collector.
        </item>
    </string-array>
    <string-array name="java_heap_">
        <item name = "definition"> What is structure of Java Heap ? What is Perm Gen space in Heap ?</item>
        <item name = "code">
            The JVM has a heap that is the runtime data area from which memory for all class instances and arrays is allocated. It is created at the JVM start-up.
            Heap memory for objects is reclaimed by an automatic memory management system which is known as a garbage collector. Heap memory consists of live and
            dead objects. Live objects are accessible by the application and will not be a subject of garbage collection. Dead objects are those which will never
            be accessible by the application, but have not been collected by the garbage collector yet. Such objects occupy the heap memory space until they are
            eventually collected by the garbage collector.
        </item>
    </string-array>
    <string-array name="serial_and_throughput_garbage_">
        <item name = "definition">What is the difference between Serial and Throughput Garbage collector ?</item>
        <item name = "code">
            The throughput garbage collector uses a parallel version of the young generation collector and is
            meant to be used with applications that have medium to large data sets. On the other hand, the serial
            collector is usually adequate for most small applications (those requiring heaps of up to approximately 100MB on modern processors).
        </item>
    </string-array>
    <string-array name="garbage_collection_">
        <item name = "definition">When does an Object becomes eligible for Garbage collection in Java ?</item>
        <item name = "code">
            A Java object is subject to garbage collection when it becomes unreachable to the program in which it is currently used.
        </item>
    </string-array>
    <string-array name="permanent_generation_space_">
        <item name = "definition">Does Garbage collection occur in permanent generation space in JVM ?</item>
        <item name = "code">
            Garbage Collection does occur in PermGen space and if PermGen space is full or cross a threshold, it can trigger a full garbage collection.
            If you look carefully at the output of the garbage collector, you will find that PermGen space is also garbage collected. This is the reason
            why correct sizing of PermGen space is important to avoid frequent full garbage collections. Also check our article Java 8: PermGen to Metaspace.
        </item>
    </string-array>

    <string-array name="exceptions_in_java_">
        <item name = "definition">What are the two types of Exceptions in Java ? Which are the differences between them ?</item>
        <item name = "code">
            Java has two types of exceptions: checked exceptions and unchecked exceptions. Unchecked exceptions do not need to be declared
            in a method or a constructor’s throws clause, if they can be thrown by the execution of the method or the constructor,
            and propagate outside the method or constructor boundary. On the other hand, checked exceptions must be declared in a
            method or a constructor’s throws clause.
        </item>
    </string-array>

    <string-array name="exception_and_error_">
        <item name = "definition">What is the difference between Exception and Error in java ?</item>
        <item name = "code">
            Exception and Error classes are both subclasses of the Throwable class. The Exception class is used for exceptional conditions that
            a user’s program should catch. The Error class defines exceptions that are not excepted to be caught by the user program.
        </item>
    </string-array>

    <string-array name="throw_and_throws_">
        <item name = "definition">What is the difference between Exception and Error in java ?</item>
        <item name = "code">
            Exception and Error classes are both subclasses of the Throwable class. The Exception class is used for exceptional conditions that
            a user’s program should catch. The Error class defines exceptions that are not excepted to be caught by the user program.
        </item>
    </string-array>

    <string-array name="finally_block_">
        <item name = "definition">What is the importance of finally block in exception handling ?</item>
        <item name = "code">
            A finally block will always be executed, whether or not an exception is actually thrown. Even in the case where the catch statement
            is missing and an exception is thrown, the finally block will still be executed. Last thing to mention is that the finally block is
            used to release resources like I/O buffers, database connections, etc.
        </item>
    </string-array>

    <string-array name="exception_object_">
        <item name = "definition">What will happen to the Exception object after exception handling ?</item>
        <item name = "code">
            The Exception object will be garbage collected in the next garbage collection.
        </item>
    </string-array>

    <string-array name="finalize_block_">
        <item name = "definition">How does finally block differ from finalize() method ?</item>
        <item name = "code">
            A finally block will be executed whether or not an exception is thrown and is used to release
            those resources held by the application. Finalize is a protected method of the Object class,
            which is called by the Java Virtual Machine (JVM) just before an object is garbage collected.
        </item>
    </string-array>

    <string-array name="what_is_an_applet_">
        <item name = "definition">What is an Applet ?</item>
        <item name = "code">
            A java applet is program that can be included in a HTML page and be executed in a java enabled client browser.
            Applets are used for creating dynamic and interactive web applications.
        </item>
    </string-array>

    <string-array name="life_cycle_of_an_applet_">
        <item name = "definition">Explain the life cycle of an Applet.</item>
        <item name = "code">
            An applet may undergo the following states:\n
            Init: An applet is initialized each time is loaded.\n
            Start: Begin the execution of an applet.\n
            Stop: Stop the execution of an applet.\n
            Destroy: Perform a final cleanup, before unloading the applet.
        </item>
    </string-array>
    <string-array name="applet_is_loaded_">
        <item name = "definition">What happens when an applet is loaded ?</item>
        <item name = "code">
            First of all, an instance of the applet’s controlling class is created. Then, the applet initializes itself and finally, it starts running.
        </item>
    </string-array>

    <string-array name="applet_and_a_java_application_">
        <item name = "definition">What is the difference between an Applet and a Java Application ?</item>
        <item name = "code">
            Applets are executed within a java enabled browser, but a Java application is a standalone Java program that can be executed outside of a browser.
            However, they both require the existence of a Java Virtual Machine (JVM). Furthermore, a Java application requires a main method with a specific signature,
            in order to start its execution. Java applets don’t need such a method to start their execution. Finally, Java applets typically use a restrictive
            security policy, while Java applications usually use more relaxed security policies.
        </item>
    </string-array>
    <string-array name="restrictions_imposed_on_java_applets_">
        <item name = "definition">What are the restrictions imposed on Java applets ?</item>
        <item name = "code">
            Mostly due to security reasons, the following restrictions are imposed on Java applets:
            An applet cannot load libraries or define native methods.\n
            An applet cannot ordinarily read or write files on the execution host.\n
            An applet cannot read certain system properties.\n
            An applet cannot make network connections except to the host that it came from.\n
            An applet cannot start any program on the host that’s executing it.
        </item>
    </string-array>
    <string-array name="untrusted_applets_">
        <item name = "definition">What are untrusted applets ?</item>
        <item name = "code">
            Untrusted applets are those Java applets that cannot access or execute local system files. By default, all downloaded applets are considered as untrusted.
        </item>
    </string-array>
    <string-array name="applets_loaded_">
        <item name = "definition">What is the difference between applets loaded over the internet and applets loaded via the file system ?</item>
        <item name = "code">
            Regarding the case where an applet is loaded over the internet, the applet is loaded by the applet classloader and is subject to the restrictions enforced
            by the applet security manager. Regarding the case where an applet is loaded from the client’s local disk, the applet is loaded by the file system loader.
            Applets loaded via the file system are allowed to read files, write files and to load libraries on the client. Also, applets loaded via the file system are
            allowed to execute processes and finally, applets loaded via the file system are not passed through the byte code verifier.
        </item>
    </string-array>
    <string-array name="applet_class_loader_">
        <item name = "definition">What is the applet class loader, and what does it provide ?</item>
        <item name = "code">
            When an applet is loaded over the internet, the applet is loaded by the applet classloader. The class loader enforces the Java name space hierarchy.
            Also, the class loader guarantees that a unique namespace exists for classes that come from the local file system, and that a unique namespace exists
            for each network source. When a browser loads an applet over the net, that applet’s classes are placed in a private namespace associated with the
            applet’s origin. Then, those classes loaded by the class loader are passed through the verifier.The verifier checks that the class file conforms to
            the Java language specification . Among other things, the verifier ensures that there are no stack overflows or underflows and that the parameters to
            all bytecode instructions are correct
        </item>
    </string-array>
    <string-array name="applet_security_manager_">
        <item name = "definition">What is the applet security manager, and what does it provide ?</item>
        <item name = "code">
            The applet security manager is a mechanism to impose restrictions on Java applets. A browser may only have one security manager. The security manager
            is established at startup, and it cannot thereafter be replaced, overloaded, overridden, or extended.
        </item>
    </string-array>

    <string-array name="choice_and_a_list_">
        <item name = "definition">What is the difference between a Choice and a List ?</item>
        <item name = "code">
            A Choice is displayed in a compact form that must be pulled down, in order for a user to be able to see the list of all available choices.
            Only one item may be selected from a Choice. A List may be displayed in such a way that several List items are visible. A List supports
            the selection of one or more List items.
        </item>
    </string-array>

    <string-array name="layout_manager_">
        <item name = "definition">What is a layout manager ?</item>
        <item name = "code">
            A layout manager is the used to organize the components in a container.
        </item>
    </string-array>

    <string-array name="scrollbar_">
        <item name = "definition">What is the difference between a Scrollbar and a JScrollPane ?</item>
        <item name = "code">
            A Scrollbar is a Component, but not a Container. A ScrollPane is a Container. A ScrollPane handles its own events and performs its own scrolling.
        </item>
    </string-array>
    <string-array name="threadsafe_">
        <item name = "definition">Which Swing methods are thread-safe ?</item>
        <item name = "code">
            There are only three thread-safe methods: repaint, revalidate, and invalidate.
        </item>
    </string-array>
    <string-array name="component_subclasses_">
        <item name = "definition">Name three Component subclasses that support painting. </item>
        <item name = "code">
            The Canvas, Frame, Panel, and Applet classes support painting.
        </item>
    </string-array>
    <string-array name="clipping_">
        <item name = "definition">What is clipping ?</item>
        <item name = "code">
            Clipping is defined as the process of confining paint operations to a limited area or shape.
        </item>
    </string-array>
    <string-array name="menuitem_and_a_checkboxmenuitem_">
        <item name = "definition">What is the difference between a MenuItem and a CheckboxMenuItem ? </item>
        <item name = "code">
            The CheckboxMenuItem class extends the MenuItem class and supports a menu item that may be either checked or unchecked.
        </item>
    </string-array>
    <string-array name="borderlayout_">
    <item name = "definition">How are the elements of a BorderLayout organized ? </item>
        <item name = "code">
            The elements of a BorderLayout are organized at the borders (North, South, East, and West) and the center of a container.
        </item>
    </string-array>
    <string-array name="gridbaglayout_">
        <item name = "definition">How are the elements of a GridBagLayout organized ?</item>
        <item name = "code">
            The elements of a GridBagLayout are organized according to a grid. The elements are of different sizes and may occupy more
            than one row or column of the grid. Thus, the rows and columns may have different sizes.
        </item>
    </string-array>
    <string-array name="window_and_a_frame_">
    <item name = "definition">What is the difference between a Window and a Frame ?</item>
    <item name = "code">
        The Frame class extends the Window class and defines a main application window that can have a menu bar.
    </item>
    </string-array>
    <string-array name="clipping_and_repainting_">
        <item name = "definition">What is the relationship between clipping and repainting ?</item>
        <item name = "code">
            When a window is repainted by the AWT painting thread, it sets the clipping regions to the area of the window that requires repainting.
        </item>
        </string-array>
    <string-array name="event_listener_">
        <item name = "definition">What is the relationship between an event-listener interface and an event-adapter class ?</item>
        <item name = "code">
            An event-listener interface defines the methods that must be implemented by an event handler for a particular event. An event adapter provides
            a default implementation of an event-listener interface.
        </item>
    </string-array>

    <string-array name="gui_component_">
        <item name = "definition">How can a GUI component handle its own events ?</item>
        <item name = "code">
            A GUI component can handle its own events, by implementing the corresponding event-listener interface and adding itself as its own event listener.
        </item>
    </string-array>

    <string-array name="traditional_windowing_systems_">
        <item name = "definition">What advantage do Java’s layout managers provide over traditional windowing systems ? </item>
        <item name = "code">
            Java uses layout managers to lay out components in a consistent manner, across all windowing platforms. Since layout managers aren’t tied to absolute
            sizing and positioning, they are able to accomodate platform-specific differences among windowing systems.
        </item>
    </string-array>
    <string-array name="design_pattern_">
        <item name = "definition">What is the design pattern that Java uses for all Swing components ?</item>
        <item name = "code">
            The design pattern used by Java for all Swing components is the Model View Controller (MVC) pattern.
        </item>
    </string-array>

    <string-array name="what_is_jdbc_">
        <item name = "definition">What is JDBC ?</item>
        <item name = "code">
            JDBC is an abstraction layer that allows users to choose between databases. JDBC enables developers to write database applications
            in Java, without having to concern themselves with the underlying details of a particular databas
        </item>
    </string-array>

    <string-array name="driver_in_jdbc_">
        <item name = "definition">Explain the role of Driver in JDBC.</item>
        <item name = "code">
            The JDBC Driver provides vendor-specific implementations of the abstract classes provided by the JDBC API. Each driver must provide
            implementations for the following classes of the java.sql package:Connection, Statement, PreparedStatement, CallableStatement, ResultSet and Driver.
        </item>
    </string-array>

    <string-array name="class_forname_">
        <item name = "definition">Explain the role of Driver in JDBC.</item>
        <item name = "code">
            The JDBC Driver provides vendor-specific implementations of the abstract classes provided by the JDBC API. Each driver must provide
            implementations for the following classes of the java.sql package:Connection, Statement, PreparedStatement, CallableStatement, ResultSet and Driver.
        </item>
    </string-array>

    <string-array name="prepared_statement_">
        <item name = "definition">Explain the role of Driver in JDBC.</item>
        <item name = "code">
            The JDBC Driver provides vendor-specific implementations of the abstract classes provided by the JDBC API. Each driver must provide
            implementations for the following classes of the java.sql package:Connection, Statement, PreparedStatement, CallableStatement, ResultSet and Driver.
        </item>
    </string-array>

    <string-array name="callablestatement_">
        <item name = "definition">Explain the role of Driver in JDBC.</item>
        <item name = "code">
            The JDBC Driver provides vendor-specific implementations of the abstract classes provided by the JDBC API. Each driver must provide
            implementations for the following classes of the java.sql package:Connection, Statement, PreparedStatement, CallableStatement, ResultSet and Driver.
        </item>
    </string-array>

    <string-array name="connection_pooling_">
        <item name = "definition">Explain the role of Driver in JDBC.</item>
        <item name = "code">
            The JDBC Driver provides vendor-specific implementations of the abstract classes provided by the JDBC API. Each driver must provide
            implementations for the following classes of the java.sql package:Connection, Statement, PreparedStatement, CallableStatement, ResultSet and Driver.
        </item>
    </string-array>

    <string-array name="what_is_rmi_">
        <item name = "definition">What is RMI ?</item>
        <item name = "code">
            The Java Remote Method Invocation (Java RMI) is a Java API that performs the object-oriented equivalent of remote procedure calls (RPC),
            with support for direct transfer of serialized Java classes and distributed garbage collection. Remote Method Invocation (RMI) can also
            be seen as the process of activating a method on a remotely running object. RMI offers location transparency because a user feels that
            a method is executed on a locally running object.
        </item>
    </string-array>

    <string-array name="basic_principle_of_rmi_">
        <item name = "definition">What is the basic principle of RMI architecture ?</item>
        <item name = "code">
            The RMI architecture is based on a very important principle which states that the definition of the behavior and the implementation of
            that behavior, are separate concepts. RMI allows the code that defines the behavior and the code that implements the behavior to remain
            separate and to run on separate JVMs.
        </item>
    </string-array>
    <string-array name="rmi_architecture_">
        <item name = "definition">What are the layers of RMI Architecture ?</item>
        <item name = "code">
            Stub and Skeleton layer: This layer lies just beneath the view of the developer. This layer is responsible for intercepting method calls
            made by the client to the interface and redirect these calls to a remote RMI Service.\n
            Remote Reference Layer: The second layer of the RMI architecture deals with the interpretation of references made from the client to the
            server’s remote objects. This layer interprets and manages references made from clients to the remote service objects. The connection is
            a one-to-one (unicast) link.\n
            Transport layer: This layer is responsible for connecting the two JVM participating in the service. This layer is based on TCP/IP connections
            between machines in a network. It provides basic connectivity, as well as some firewall penetration strategies.
        </item>
    </string-array>
    <string-array name="remote_interface_in_rmi_">
    <item name = "definition">What is the role of Remote Interface in RMI ?</item>
    <item name = "code">
        The Remote interface serves to identify interfaces whose methods may be invoked from a non-local virtual machine. Any object that is a remote
        object must directly or indirectly implement this interface. A class that implements a remote interface should declare the remote interfaces being
        implemented, define the constructor for each remote object and provide an implementation for each remote method in all remote interfaces.
    </item>
    </string-array>
    <string-array name="java_rmi_naming_class_">
    <item name = "definition">What is the role of the java.rmi.Naming Class ?</item>
    <item name = "code">
        The java.rmi.Naming class provides methods for storing and obtaining references to remote objects in the remote object registry. Each method of
        the Naming class takes as one of its arguments a name that is a String in URL format.
    </item>
    </string-array>
    <string-array name="binding_in_rmi_">
    <item name = "definition">What is meant by binding in RMI ?</item>
    <item name = "code">
        Binding is the process of associating or registering a name for a remote object, which can be used at a later time, in order to look up that
        remote object. A remote object can be associated with a name using the bind or rebind methods of the Naming class.
    </item>
    </string-array>
    <string-array name="bind_and_rebind_methods_of_naming_class_">
    <item name = "definition">What is the difference between using bind() and rebind() methods of Naming Class ?</item>
    <item name = "code">
        The bind method bind is responsible for binding the specified name to a remote object, while the rebind method is responsible for rebinding the
        specified name to a new remote object. In case a binding exists for that name, the binding is replaced.
    </item>
    </string-array>
    <string-array name="steps_involved_to_make_work_a_rmi_program_">
    <item name = "definition">What are the steps involved to make work a RMI program ?</item>
    <item name = "code">
        The following steps must be involved in order for a RMI program to work properly:
        Compilation of all source files.\n
        Generatation of the stubs using rmic.\n
        Start the rmiregistry.\n
        Start the RMIServer.\n
        Run the client program.
    </item>
    </string-array>
    <string-array name="role_of_stub_">
    <item name = "definition"> What is the role of stub in RMI ? </item>
    <item name = "code">
        A stub for a remote object acts as a client’s local representative or proxy for the remote object. The caller invokes a method on the local stub, which
        is responsible for executing the method on the remote object. When a stub’s method is invoked, it undergoes the following steps:
        It initiates a connection to the remote JVM containing the remote object.\n
        It marshals the parameters to the remote JVM.\n
        It waits for the result of the method invocation and execution.\n
        It unmarshals the return value or an exception if the method has not been successfully executed.\n
        It returns the value to the caller.
    </item>
    </string-array>
    <string-array name="dgc_">
    <item name = "definition">What is DGC ? And how does it work ?</item>
    <item name = "code">
        DGC stands for Distributed Garbage Collection. Remote Method Invocation (RMI) uses DGC for automatic garbage collection. Since RMI involves remote
        object references across JVM’s, garbage collection can be quite difficult. DGC uses a reference counting algorithm to provide automatic memory
        management for remote objects.
    </item>
    </string-array>
    <string-array name="marshalling_and_demarshalling_">
    <item name = "definition">Explain Marshalling and demarshalling</item>
    <item name = "code">
        When an application wants to pass its memory objects across a network to another host or persist it to storage, the in-memory representation must be
        converted to a suitable format. This process is called marshalling and the revert operation is called demarshalling.
    </item>
    </string-array>
    <string-array name="serialization_and_deserialization_">
    <item name = "definition">Explain Serialization and Deserialization.</item>
    <item name = "code">
        Java provides a mechanism, called object serialization where an object can be represented as a sequence of bytes and includes the object’s data, as
        well as information about the object’s type, and the types of data stored in the object. Thus, serialization can be seen as a way of flattening
        objects, in order to be stored on disk, and later, read back and reconstituted. Deserialisation is the reverse process of converting an object from
        its flattened state to a live object.
    </item>
    </string-array>

    <string-array name="what_is_a_servlet_">
        <item name = "definition">What is a Servlet ?</item>
        <item name = "code">
            The servlet is a Java programming language class used to process client requests and generate dynamic web content.
            Servlets are mostly used to process or store data submitted by an HTML form, provide dynamic content and manage state
            information that does not exist in the stateless HTTP protocol.
        </item>
    </string-array>

    <string-array name="architechure_of_a_servlet_">
        <item name = "definition">Explain the architechure of a Servlet.</item>
        <item name = "code">
            The core abstraction that must be implemented by all servlets is the javax.servlet.Servlet interface. Each servlet
            must implement it either directly or indirectly, either by extending javax.servlet.GenericServlet or javax.servlet.http.HTTPServlet.
            Finally, each servlet is able to serve multiple requests in parallel using multithreading.
        </item>
    </string-array>

    <string-array name="applet_and_a_servlet_">
        <item name = "definition">What is the difference between an Applet and a Servlet ?</item>
        <item name = "code">
            An Applet is a client side java program that runs within a Web browser on the client machine. On the other hand, a servlet is a server
            side component that runs on the web server.An applet can use the user interface classes, while a servlet does not have a user interface.
            Instead, a servlet waits for client’s HTTP requests and generates a response in every request.
        </item>
    </string-array>
    <string-array name="genericservlet_and_httpservlet_">
    <item name = "definition">What is the difference between GenericServlet and HttpServlet ?</item>
        <item name = "code">
            GenericServlet is a generalized and protocol-independent servlet that implements the Servlet and ServletConfig interfaces. Those servlets
            extending the GenericServlet class shall override the service method. Finally, in order to develop an HTTP servlet for use on the Web that
            serves requests using the HTTP protocol, your servlet must extend the HttpServlet instead.
        </item>
    </string-array>

    <string-array name="life_cycle_of_a_servlet_">
    <item name = "definition">Explain the life cycle of a Servlet.</item>
        <item name = "code">
            On every client\’s request, the Servlet Engine loads the servlets and invokes its init methods, in order for the servlet to be initialized.
            Then, the Servlet object handles all subsequent requests coming from that client, by invoking the service method for each request separately.
            Finally, the servlet is removed by calling the server\’s destroy method.
        </item>
    </string-array>

    <string-array name="doget_and_dopost_">
    <item name = "definition">What is the difference between doGet() and doPost() ?</item>
        <item name = "code">
            The GET method appends the name-value pairs on the request\’s URL. Thus, there is a limit on the number of characters and subsequently on the
            number of values that can be used in a client\’s request. Furthermore, the values of the request are made visible and thus, sensitive information
            must not be passed in that way. doPOST: The POST method overcomes the limit imposed by the GET request, by sending the values of the request inside
            its body. Also, there is no limitations on the number of values to be sent across. Finally, the sensitive information passed through a POST request
            is not visible to an external client.
        </item>
    </string-array>

    <string-array name="web_application_">
    <item name = "definition">What is meant by a Web Application ?</item>
        <item name = "code">
            A Web application is a dynamic extension of a Web or application server. There are two types of web applications: presentation-oriented and
            service-oriented. A presentation-oriented Web application generates interactive web pages, which contain various types of markup language and
            dynamic content in response to requests. On the other hand, a service-oriented web application implements the endpoint of a web service.
            In general, a Web application can be seen as a collection of servlets installed under a specific subset of the server\’s URL namespace.
        </item>
    </string-array>

    <string-array name="server_side_include_">
    <item name = "definition">What is a Server Side Include (SSI) ? </item>
        <item name = "code">
            Server Side Includes (SSI) is a simple interpreted server-side scripting language, used almost exclusively for the Web, and is embedded with
            a servlet tag. The most frequent use of SSI is to include the contents of one or more files into a Web page on a Web server. When a Web page
            is accessed by a browser, the Web server replaces the servlet tag in that Web page with the hyper text generated by the corresponding servlet.
        </item>
    </string-array>

    <string-array name="servlet_chaining_">
    <item name = "definition">What is Servlet Chaining ?</item>
        <item name = "code">
            Servlet Chaining is the method where the output of one servlet is sent to a second servlet. The output of the second servlet can be sent to a
            third servlet, and so on. The last servlet in the chain is responsible for sending the response to the client.
        </item>
    </string-array>

    <string-array name="client_machine_">
    <item name = "definition">How do you find out what client machine is making a request to your servlet ?</item>
        <item name = "code">
            The ServletRequest class has functions for finding out the IP address or host name of the client machine. getRemoteAddr() gets the IP address
            of the client machine and getRemoteHost() gets the host name of the client machine.
        </item>
    </string-array>

    <string-array name="structure_of_the_http_response_">
    <item name = "definition">What is the structure of the HTTP response ? </item>
        <item name = "code">
            The HTTP response consists of three parts:\n
            Status Code: describes the status of the response. It can be used to check if the request has been successfully completed. In case the request
            failed, the status code can be used to find out the reason behind the failure. If your servlet does not return a status code, the success status
            code, HttpServletResponse.SC_OK, is returned by default.\n
            HTTP Headers: they contain more information about the response. For example, the headers may specify the date/time after which the response is
            considered stale, or the form of encoding used to safely transfer the entity to the user. See how to retrieve headers in Servlet here.\n
            Body: it contains the content of the response. The body may contain HTML code, an image, etc. The body consists of the data bytes transmitted in
            an HTTP transaction message immediately following the headers.
        </item>
    </string-array>

    <string-array name="session_and_cookie_">
    <item name = "definition">What is a cookie ? What is the difference between session and cookie ? </item>
        <item name = "code">
            A cookie is a bit of information that the Web server sends to the browser. The browser stores the cookies for each Web server in a local file.
            In a future request, the browser, along with the request, sends all stored cookies for that specific Web server.The differences between session
            and a cookie are the following:\n
            The session should work, regardless of the settings on the client browser. The client may have chosen to disable cookies. However, the sessions
            still work, as the client has no ability to disable them in the server side.\n
            The session and cookies also differ in the amount of information the can store. The HTTP session is capable of storing any Java object, while a
            cookie can only store String objects.\n
        </item>
    </string-array>

    <string-array name="browser_and_servlet_">
    <item name = "definition">Which protocol will be used by browser and servlet to communicate ?</item>
        <item name = "code">
            The browser communicates with a servlet by using the HTTP protocol.
        </item>
    </string-array>

    <string-array name="http_tunneling_">
    <item name = "definition">What is HTTP Tunneling ?</item>
        <item name = "code">
            HTTP Tunneling is a technique by which, communications performed using various network protocols are encapsulated using the HTTP or
            HTTPS protocols. The HTTP protocol therefore acts as a wrapper for a channel that the network protocol being tunneled uses to communicate.
            The masking of other protocol requests as HTTP requests is HTTP Tunneling.
        </item>
    </string-array>

    <string-array name="sendredirect_and_forward_methods_">
    <item name = "definition">What’s the difference between sendRedirect and forward methods ?</item>
        <item name = "code">
            The sendRedirect method creates a new request, while the forward method just forwards a request to a new target. The previous request scope
            objects are not available after a redirect, because it results in a new request. On the other hand, the previous request scope objects are
            available after forwarding. FInally, in general, the sendRedirect method is considered to be slower compare to the forward method.
        </item>
    </string-array>

    <string-array name="url_encoding_and_url_decoding_">
    <item name = "definition">What is URL Encoding and URL Decoding ?</item>
        <item name = "code">
            The URL encoding procedure is responsible for replacing all the spaces and every other extra special character of a URL, into their
            corresponding Hex representation. In correspondence, URL decoding is the exact opposite procedure.
        </item>
    </string-array>

    <!--<item>Advantages of JSP</item>-->
    <!--<item>Directives Available in JSP</item>-->
    <!--<item>JSP Actions</item>-->
    <!--<item>Scriptlets</item>-->
    <!--<item>Decalarations</item>-->
    <!--<item>Expressions</item>-->
    <!--<item>Implicit Objects</item>-->
    <string-array name="jsp_page_">
        <item name = "definition">What is a JSP Page ? </item>
        <item name = "code">
            A Java Server Page (JSP) is a text document that contains two types of text: static data and JSP elements. Static
            data can be expressed in any text-based format, such as HTML or XML. JSP is a technology that mixes static content with dynamically-generated content.
        </item>
    </string-array>

    <string-array name="jsp_requests_handled_">
        <item name = "definition">How are the JSP requests handled ?</item>
        <item name = "code">
            On the arrival of a JSP request, the browser first requests a page with a .jsp extension. Then, the Web server reads
            the request and using the JSP compiler, the Web server converts the JSP page into a servlet class. Notice that the JSP
            file is compiled only on the first request of the page, or if the JSP file has changed.The generated servlet class is
            invoked, in order to handle the browser’s request. Once the execution of the request is over, the servlet sends a
            response back to the client.
        </item>
    </string-array>

    <string-array name="advantages_of_jsp_">
        <item name = "definition">What are the advantages of JSP ?</item>
        <item name = "code">
            The advantages of using the JSP technology are shown below:\n
            JSP pages are dynamically compiled into servlets and thus, the developers can easily make updates to presentation code.\n
            JSP pages can be pre-compiled.\n
            JSP pages can be easily combined to static templates, including HTML or XML fragments, with code that generates dynamic content.\n
            Developers can offer customized JSP tag libraries that page authors access using an XML-like syntax.\n
            Developers can make logic changes at the component level, without editing the individual pages that use the application’s logic.
        </item>
    </string-array>

    <string-array name="directives_available_in_jsp_">
    <item name = "definition">What are Directives ? What are the different types of Directives available in JSP ?</item>
        <item name = "code">
            Directives are instructions that are processed by the JSP engine, when the page is compiled to a servlet. Directives are used to set page-level
            instructions, insert data from external files, and specify custom tag libraries. Directives are defined between &lt; ? and ? &gt;.The different types
            of directives are shown below: \n
            Include directive: it is used to include a file and merges the content of the file with the current page.\n
            Page directive: it is used to define specific attributes in the JSP page, like error page and buffer.\n
            Taglib: it is used to declare a custom tag library which is used in the page.
        </item>
    </string-array>

    <string-array name="jsp_actions_">
    <item name = "definition">What are JSP actions ?</item>
        <item name = "code">
            JSP actions use constructs in XML syntax to control the behavior of the servlet engine. JSP actions are executed when a JSP page is requested.
            They can be dynamically inserted into a file, re-use JavaBeans components, forward the user to another page, or generate HTML for the Java plugin.
            Some of the available actions are listed below:\n
            jsp:include – includes a file, when the JSP page is requested.\n
            jsp:useBean – finds or instantiates a JavaBean.\n
            jsp:setProperty – sets the property of a JavaBean.\n
            jsp:getProperty – gets the property of a JavaBean.\n
            jsp:forward – forwards the requester to a new page.\n
            jsp:plugin – generates browser-specific code.
        </item>
    </string-array>
    <string-array name="scriptlets_">
    <item name = "definition">What are Scriptlets ?</item>
        <item name = "code">
            In Java Server Pages (JSP) technology, a scriptlet is a piece of Java-code embedded in a JSP page. The scriptlet is everything inside the tags.
            Between these tags, a user can add any valid scriplet.
        </item>
    </string-array>
    <string-array name="decalarations_">
    <item name = "definition">What are Decalarations ?</item>
        <item name = "code">
            Declarations are similar to variable declarations in Java. Declarations are used to declare variables for subsequent use in expressions or scriptlets.
            To add a declaration, you must use the sequences to enclose your declarations.
        </item>
    </string-array>
    <string-array name="expressions_">
    <item name = "definition">What are Expressions ?</item>
        <item name = "code">
            A JSP expression is used to insert the value of a scripting language expression, converted into a string, into the data stream returned to the client,
            by the web server. Expressions are defined between &lt;? = and ? &gt; tags.
        </item>
    </string-array>
    <string-array name="implicit_objects_">
    <item name = "definition">What is meant by implicit objects and what are they ?</item>
        <item name = "code">
            JSP implicit objects are those Java objects that the JSP Container makes available to developers in each page. A developer can call them directly,
            without being explicitly declared. JSP Implicit Objects are also called pre-defined variables.The following objects are considered implicit in a JSP
            page:\n
            application\n
            page\n
            request\n
            response\n
            session\n
            exception\n
            out\n
            config\n
            pageContext
        </item>
    </string-array>

    <string-array name="algorithm">
        <item>Data Structure</item>
        <item>Basic Sorting</item>
        <item>Basic Misc</item>
        <item>String</item>
        <item>Integer Array</item>
        <item>Binary Search</item>
        <item>Math and Bit Manipulation</item>
        <item>Linked List</item>
        <item>Reverse</item>
        <item>Binary Tree</item>
        <item>Binary Search Tree</item>
        <item>Back Tracking</item>
        <item>Dynamic Programming</item>
    </string-array>

    <string-array name="basics">
        <item>Basics</item>
    </string-array>

    <string-array name="data_structure">
        <item>Linked List</item>
        <item>Binary Tree</item>
        <item>Binary Search Tree</item>
        <item>Huffman Compression</item>
        <item>Priority Queue</item>
    </string-array>

    <string-array name="basic_sorting">
        <item>Bubble Sort</item>
        <item>Selection Sort</item>
        <item>Insertion Sort</item>
        <item>Merge Sort</item>
        <item>Quick Sort</item>
        <item>Heap Sort</item>
        <item>Bucket Sort</item>
        <item>Counting Sort</item>
    </string-array>

    <string-array name="basic_misc">
        <item>Bit Manipulation</item>
    </string-array>

    <string-array name="part_II_coding">
        <item>Part II - Coding</item>
    </string-array>

    <string-array name="string">
        <item>strStr</item>
        <item>Two Strings Are Anagrams</item>
        <item>Compare Strings</item>
        <item>Anagrams</item>
        <item>Longest Common Substring</item>
    </string-array>

    <string-array name="integer_array">
        <item>Remove Element</item>
        <item>Zero Sum Subarray</item>
        <item>Subarray Sum K</item>
        <item>Subarray Sum Closest</item>
        <item>Product of Array Exclude Itself</item>
        <item>Partition Array</item>
        <item>First Missing Positive</item>
        <item>Two Sum</item>
        <item>Three Sum</item>
        <item>Three Sum Closest</item>
        <item>Remove Duplicates from Sorted Array</item>
        <item>Remove Duplicates from Sorted Array II</item>
        <item>Merge Sorted Array</item>
        <item>Merge Sorted Array II</item>
    </string-array>

    <string-array name="binary_search">
        <item>Binary Search</item>
        <item>Search Insert Position</item>
        <item>Search for a Range</item>
        <item>First Bad Version</item>
        <item>Search a 2D Matrix</item>
        <item>Find Peak Element</item>
        <item>Search in Rotated Sorted Array</item>
        <item>Find Minimum in Rotated Sorted Array</item>
        <item>Search a 2D Matrix II</item>
        <item>Median of two Sorted Arrays</item>
        <item>Sqrt x</item>
        <item>Wood Cut</item>
    </string-array>

    <string-array name="math_and_bit_manipulation">
        <item>Single Number</item>
        <item>Single Number II</item>
        <item>O 1 Check Power of 2</item>
        <item>Convert Integer A to Integer B</item>
        <item>Factorial Trailing Zeroes</item>
    </string-array>

    <string-array name="linked_list">
        <item>Remove Duplicates from Sorted List</item>
        <item>Remove Duplicates from Sorted List II</item>
        <item>Partition List</item>
        <item>Two Lists Sum</item>
        <item>Two Lists Sum Advanced</item>
        <item>Remove Nth Node From End of List</item>
        <item>Linked List Cycle</item>
        <item>Linked List Cycle II</item>
        <item>Reverse Linked List</item>
        <item>Reverse Linked List II</item>
        <item>Merge Two Sorted Lists</item>
        <item>Merge k Sorted Lists</item>
        <item>Sort List</item>
        <item>Recorder List</item>
    </string-array>

    <string-array name="reverse">
        <item>Recover Rotated Sorted Array</item>
        <item>Rotate String</item>
        <item>Reverse Words in a String</item>
    </string-array>

    <string-array name="binary_tree">
        <item>Binary Tree Preorder Traversal</item>
        <item>Binary Tree Inorder Traversal</item>
        <item>Binary Tree Postorder Traversal</item>
        <item>Binary Tree Level Order Traversal</item>
        <item>Maximum Depth of Binary Tree</item>
        <item>Balanced Binary Tree</item>
        <item>Binary Tree Maximum Path Sum</item>
        <item>Lowest Common Ancestor</item>
    </string-array>

    <string-array name="binary_search_tree">
        <item>Insert Node in a Binary Search Tree</item>
        <item>Validate Binary Search Tree</item>
        <item>Search Range in Binary Search Tree</item>
        <item>Convert Sorted Array to Binary Search Tree</item>
        <item>Convert Sorted List to Binary Search Tree</item>
        <item>Binary Search Tree Iterator</item>
    </string-array>

    <string-array name="back_tracking">
        <item>Subsets</item>
        <item>Permutation</item>
    </string-array>

    <string-array name="dynamic_programming">
        <item>Triangle</item>
        <item>Backpack</item>
        <item>Minimum Path Sum</item>
        <item>Unique Paths</item>
        <item>Climbing Stairs</item>
        <item>Jump Game</item>
    </string-array>

<string-array name="linked_list_">
        <item name = "definition"> linked list is a linear collection of data elements,
            called nodes pointing to the next node by means of pointer. It is a data
            structure consisting of a group of nodes which together represent a sequence.
            Under the simplest form, each node is composed of data and a reference (in other words,
            a link) to the next node in the sequence; more complex variants add additional links.
            This structure allows for efficient insertion or removal of elements from any position
            in the sequence.</item>
        <item name = "code">
            class ListNode {\n
            \t     int val;\n
            \t   ListNode next;\n
            \t ListNode(int x) {\n
            \t\t val = x;\n
            \t\t next = null;\n
        \t }\n
  }</item>
</string-array>
<string-array name="binary_tree_">
        <item name = "definition"> binary tree is a tree data structure in which each node has at
            most two children, which are referred to as the left child and the right child.
            A recursive definition using just set theory notions is that a (non-empty) binary
            tree is a triple (L, S, R), where L and R are binary trees or the empty set and S is a
            singleton set. Some authors allow the binary tree to be the empty set as well.
           </item>
        <item name = "code">
            public class TreeNode {\n
            \t int val;\n
            \t TreeNode left;\n
            \t TreeNode right;\n
            \t TreeNode(int x) { val = x; }\n
         }</item>
</string-array>
<string-array name="binary_search_tree_">
        <item name = "definition">  binary search trees (BST), sometimes called ordered or sorted
            binary trees, are a particular type of containers: data structures that store "items"
            (such as numbers, names etc.) in memory. They allow fast lookup, addition and removal
            of items, and can be used to implement either dynamic sets of items, or lookup tables
            that allow finding an item by its key (e.g., finding the phone number of a person by
            name).</item>
        <item name = "code">
          /**
 * Definition for a binary tree node.\n
 * public class TreeNode {\n
 *     int val;\n
 *     TreeNode left;\n
 *     TreeNode right;\n
 *     TreeNode(int x) { val = x; }\n
 * }\n
 */\n
public class Solution {\n
\t    public boolean isValidBST(TreeNode root) {\n
     \t\t   return isValidBST(root, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n
\t    }\n
\t    public boolean isValidBST(TreeNode root, double min, double max){\n

\t    \t    if(root == null) return true;\n
\t    \t     double value = root.val * 1.0;\n
\t    \t    if(root.val &lt; = min || root.val >= max) return false;\n
\n
\t    \t    return isValidBST(root.left, min, value) &amp;&amp; isValidBST(root.right, value, max);\n
\t    }\n
}</item>
</string-array>

<string-array name="huffman_compression_">
        <item name ="algorithm"> Huffman coding is an entropy encoding algorithm used for lossless
            data compression. The term refers to the use of a variable-length code table for encoding
            a source symbol (such as a character in a file) where the variable-length code table has
            been derived in a particular way based on the estimated probability of occurrence for
            each possible value of the source symbol.</item>
        <item name = "code">
public final class HuffmanCompress {\n
\n
	\t public static void main(String[] args) throws IOException {\n
	\t\	// Show what command line arguments to use\n
	\t\	if (args.length == 0) {\n
	\t\t		System.err.println("Usage: java HuffmanCompress InputFile OutputFile");\n
	\t\t		System.exit(1);\n
	\t\t		return;\n
	\t\	}\n
\n
	\t\t	// Otherwise, compress\n
	\t\t	File inputFile = new File(args[0]);\n
	\t\t	File outputFile = new File(args[1]);\n
\n
	\t\t	// Read input file once to compute symbol frequencies\n
	\t\t	// The resulting generated code is optimal for static Huffman coding and also canonical\n
	\t\t	FrequencyTable freq = getFrequencies(inputFile);\n
	\t\t	freq.increment(256);  // EOF symbol gets a frequency of 1\n
	\t\t	CodeTree code = freq.buildCodeTree();\n
	\t\t	CanonicalCode canonCode = new CanonicalCode(code, 257);\n
	\t\t	code = canonCode.toCodeTree();  // Replace code tree with canonical one. For each symbol, the code value may change but the code length stays the same.\n
\n
	\t\t	// Read input file again, compress with Huffman coding, and write output file\n
	\t\t	InputStream in = new BufferedInputStream(new FileInputStream(inputFile));\n
	\t\t	BitOutputStream out = new BitOutputStream(new BufferedOutputStream(new FileOutputStream(outputFile)));\n
	\t\t	try {\n
	\t\t		writeCode(out, canonCode);\n
	\t\t		compress(code, in, out);\n
	\t	} finally {\n
	\t\t		out.close();\n
	\t\t		in.close();\n
	\t	}\n
	}\n
\n
	\t private static FrequencyTable getFrequencies(File file) throws IOException {\n
	\t\t	FrequencyTable freq = new FrequencyTable(new int[257]);\n
	\t\t	InputStream input = new BufferedInputStream(new FileInputStream(file));\n
	\t\t	try {\n
	\t\t\t		while (true) {\n
	\t\t\t			int b = input.read();\n
	\t\t\t			if (b == -1)\n
	\t\t\t\t				break;\n
	\t\t\t			freq.increment(b);\n
	\t\t		}\n
	\t	} finally {\n
	\t\t		input.close();\n
	\t	}\n
	\t\t	return freq;\n
	}\n
\n
	\t static void writeCode(BitOutputStream out, CanonicalCode canonCode) throws IOException {\n
	\t\t	for (int i = 0; i &lt; canonCode.getSymbolLimit(); i++) {\n
	\t\t\t		int val = canonCode.getCodeLength(i);\n
	\t\t\t		// For this file format, we only support codes up to 255 bits long\n
	\t\t\t		if (val >= 256)\n
	\t\t\t\t			throw new RuntimeException("The code for a symbol is too long");\n
\n
	\t\t\t		// Write value as 8 bits in big endian\n
	\t\t\t		for (int j = 7; j >= 0; j--)\n
	\t\t\t\t			out.write((val >>> j) &amp; 1);\n
	\t\t	}\n
	\t }\n
	\t static void compress(CodeTree code, InputStream in, BitOutputStream out) throws IOException {\n
	\t\t	HuffmanEncoder enc = new HuffmanEncoder(out);\n
	\t\t	enc.codeTree = code;\n
	\t\t	while (true) {\n
	\t\t		int b = in.read();\n
	\t\t		if (b == -1)\n
	\t\t			break;\n
	\t\t		enc.write(b);\n
	\t	}\n
	\t	enc.write(256);  // EOF\n
	}\n
}</item>
</string-array>

<string-array name="priority_queue_">
        <item name = "definition">priority queue is an abstract data type which is like a regular
            queue or stack data structure, but where additionally each element has a "priority"
            associated with it. In a priority queue, an element with high priority is served before
            an element with low priority. If two elements have the same priority, they are served
            according to their order in the queue.</item>
        <item name = "code">
public class PriorityQueueTest {\n
\n
\t	static class PQsort implements Comparator &lt;Integer> {\n
\n
\t\t		public int compare(Integer one, Integer two) {\n
\t\t\t			return two - one;\n
\t\t		}\n
\t	}\n
\n
\t	public static void main(String[] args) {\n
\t\t		int[] ia = { 1, 10, 5, 3, 4, 7, 6, 9, 8 };\n
\t\t		PriorityQueue &lt;Integer> pq1 = new PriorityQueue &lt;Integer>();\n
\n
\t\t		// use offer() method to add elements to the PriorityQueue pq1\n
\t\t		for (int x : ia) {\n
\t\t\t			pq1.offer(x);\n
\t\t		}\n
\n
\t\t		System.out.println("pq1: " + pq1);\n
\n
\t\t		PQsort pqs = new PQsort();\n
\t\t		PriorityQueue &lt;Integer> pq2 = new PriorityQueue &lt;Integer>(10, pqs);\n
\t\t		// In this particular case, we can simply use Collections.reverseOrder()\n
\t\t		// instead of self-defined comparator\n
\t\t		for (int x : ia) {\n
\t\t\t			pq2.offer(x);\n
\t\t		}\n
\n
\t\t		System.out.println("pq2: " + pq2);\n
\n
\t\t		// print size\n
\t\t		System.out.println("size: " + pq2.size());\n
\t\t		// return highest priority element in the queue without removing it\n
\t\t		System.out.println("peek: " + pq2.peek());\n
\t\t		// print size\n
\t\t		System.out.println("size: " + pq2.size());\n
\t\t		// return highest priority element and removes it from the queue\n
\t\t		System.out.println("poll: " + pq2.poll());\n
\t\t		// print size\n
\t\t		System.out.println("size: " + pq2.size());\n
\n
\t\t		System.out.print("pq2: " + pq2);\n
\n
\t	}\n
}</item>
</string-array>
<string-array name="bubble_sort_">
        <item name = "definition"> Bubble sort, sometimes referred to as sinking sort, is a simple
            sorting algorithm that repeatedly steps through the list to be sorted, compares each
            pair of adjacent items and swaps them if they are in the wrong order. The pass through
            the list is repeated until no swaps are needed, which indicates that the list is sorted.
            The algorithm, which is a comparison sort, is named for the way smaller elements
            "bubble" to the top of the list. Although the algorithm is simple, it is too slow and
            impractical for most problems even when compared to insertion sort.[1] It can be
            practical if the input is usually in sort order but may occasionally have some
            out-of-order elements nearly in position.</item>
        <item name = "code">
class BubbleSort {\n
\t  public static void main(String []args) {\n
\t\t    int n, c, d, swap;\n
\t\t    Scanner in = new Scanner(System.in);\n
\n
\t\t    System.out.println("Input number of integers to sort");\n
\t\t    n = in.nextInt();\n
\n
\t\t    int array[] = new int[n];\n
\n
\t\t    System.out.println("Enter " + n + " integers");\n
\n
 \t\t   for (c = 0; c &lt; n; c++)\n
            \t\t\t    array[c] = in.nextInt();\n
\n
 \t\t   for (c = 0; c &lt; ( n - 1 ); c++) {\n
 \t\t\t     for (d = 0; d &lt; n - c - 1; d++) {\n
  \t\t\t      if (array[d] > array[d+1]) /* For descending order use &lt; */\n
        {\n
  \t\t\t\t        swap       = array[d];\n
   \t\t\t\t       array[d]   = array[d+1];\n
   \t\t\t\t      array[d+1] = swap;\n
     \t\t\t   }\n
   \t\t   }\n
  \t  }\n
\n
  \t  System.out.println("Sorted list of numbers");\n
\n
  \t  for (c = 0; c &lt; n; c++)\n
  \t    System.out.println(array[c]);\n
  }\n
}</item>
</string-array>
<string-array name="selection_sort_">
        <item name = "definition">selection sort is a sorting algorithm, specifically an in-place
            comparison sort. It has O(n2) time complexity, making it inefficient on large lists,
            and generally performs worse than the similar insertion sort. Selection sort is noted
            for its simplicity, and it has performance advantages over more complicated algorithms
            in certain situations, particularly where auxiliary memory is limited.</item>
        <item name = "code">
       public class MySelectionSort {\n
\t    public static int[] doSelectionSort(int[] arr){\n
\n
\t\t        for (int i = 0; i &lt; arr.length - 1; i++)\n
\t\t        {\n
\t\t\t            int index = i;\n
 \t\t\t           for (int j = i + 1; j &lt; arr.length; j++)\n
 \t\t\t\t               if (arr[j] &lt; arr[index])\n
  \t\t\t\t                  index = j;\n
\n
   \t\t\t         int smallerNumber = arr[index];\n
   \t\t\t         arr[index] = arr[i];\n
   \t\t\t         arr[i] = smallerNumber;\n
   \t\t     }\n
    \t\t    return arr;\n
  \t  }\n
\n
\t    public static void main(String a[]){\n
\n
\t\t        int[] arr1 = {10,34,2,56,7,67,88,42};\n
\t\t        int[] arr2 = doSelectionSort(arr1);\n
\t\t        for(int i:arr2){\n
\t\t\t            System.out.print(i);\n
\t\t\t            System.out.print(", ");\n
\t\t        }\n
\t    }\n
}\n
</item>
</string-array><string-array name="insertion_sort_">
        <item name = "definition"> Insertion sort is a simple sorting algorithm that builds the
            final sorted array (or list) one item at a time. It is much less efficient on large
            lists than more advanced algorithms such as quicksort, heapsort, or merge sort. However,
            insertion sort provides several advantages:\n
            1.Simple implementation: Bentley shows a three-line C version, and a five-line optimized
            version.\n
            2.Efficient for (quite) small data sets, much like other quadratic sorting algorithms.\n
            3.More efficient in practice than most other simple quadratic (i.e., O(n2)) algorithms
            such as selection sort or bubble sort.\n
            4.Adaptive, i.e., efficient for data sets that are already substantially sorted: the
            time complexity is O(nk) when each element in the input is no more than k places away
            from its sorted position.\n
            5.Stable; i.e., does not change the relative order of elements with equal keys.\n
            6.In-place; i.e., only requires a constant amount O(1) of additional memory space.\n
            7.Online; i.e., can sort a list as it receives it.\n</item>
        <item name = "code">
           public class MyInsertionSort {\n

    public static void main(String[] args) {\n

\t        int[] input = { 4, 2, 9, 6, 23, 12, 34, 0, 1 };\n
\t        insertionSort(input);\n
    }\n
\n
    private static void printNumbers(int[] input) {\n
\n
 \t       for (int i = 0; i &lt; input.length; i++) {\n
 \t\t           System.out.print(input[i] + ", ");\n
 \t       }\n
 \t       System.out.println("\n");\n
    }\n
    public static void insertionSort(int array[]) {\n
 \t       int n = array.length;\n
 \t       for (int j = 1; j &lt; n; j++) {\n
 \t\t           int key = array[j];\n
 \t\t           int i = j-1;\n
 \t\t           while ( (i > -1) &amp;&amp; ( array [i] > key ) ) {\n
 \t\t\t               array [i+1] = array [i];\n
  \t\t\t              i--;\n
 \t\t           }\n
 \t\t           array[i+1] = key;\n
 \t\t           printNumbers(array);\n
 \t       }\n
    }\n
}
</item>
</string-array><string-array name="merge_sort_">
        <item name = "definition"> merge sort (also commonly spelled mergesort) is an efficient,
            general-purpose, comparison-based sorting algorithm. Most implementations produce a
            stable sort, which means that the implementation preserves the input order of equal
            elements in the sorted output. Mergesort is a divide and conquer algorithm that was
            invented by John von Neumann in 1945. A detailed description and analysis of  bottom-up
            mergesort appeared in a report by Goldstine and Neumann as early as 1948.</item>
        <item name = "code">
        TopDownMergeSort(A[], B[], n){\n
\t    TopDownSplitMerge(A, 0, n, B);\n
}\n

// iBegin is inclusive; iEnd is exclusive (A[iEnd] is not in the set).
TopDownSplitMerge(A[], iBegin, iEnd, B[]){\n
\t    if(iEnd - iBegin &lt; 2)                   // if run size == 1\n
\t\t        return;                                 //   consider it sorted\n
\t    // recursively split runs into two halves until run size == 1,\n
 \t   // then merge them and return back up the call chain\n
 \t   iMiddle = (iEnd + iBegin) / 2;              // iMiddle = mid point\n
\t    TopDownSplitMerge(A, iBegin,  iMiddle, B);  // split / merge left  half\n
\t    TopDownSplitMerge(A, iMiddle,    iEnd, B);  // split / merge right half\n
\t    TopDownMerge(A, iBegin, iMiddle, iEnd, B);  // merge the two half runs\n
\t    CopyArray(B, iBegin, iEnd, A);              // copy the merged runs back to A\n
}\n
\n
//  Left half is A[iBegin :iMiddle-1].\n
// Right half is A[iMiddle:iEnd-1   ].\n
TopDownMerge(A[], iBegin, iMiddle, iEnd, B[])\n
{\n
\t    i = iBegin, j = iMiddle;\n
\n
\t    // While there are elements in the left or right runs...\n
\t    for (k = iBegin; k &lt; iEnd; k++) {\n
\t\t        // If left run head exists and is &lt;= existing right run head.\n
 \t\t       if (i &lt; iMiddle &amp;&amp;(j >= iEnd || A[i] &lt;= A[j])) {\n
 \t\t\t           B[k] = A[i];\n
  \t\t\t          i = i + 1;\n
  \t\t      } else {\n
  \t\t\t          B[k] = A[j];\n
   \t\t\t         j = j + 1;\n
  \t\t      }\n
  \t  }\n
}\n
\n
CopyArray(B[], iBegin, iEnd, A[]){\n
\t    for(k = iBegin; k &lt; iEnd; k++)\n
\t\t        A[k] = B[k];\n
}\n
\t        //Bottom-up implementation\n
\t            //**********************************************//\n
\t            void BottomUpMergeSort(A[], B[], n)\n
{\n
 \t // Each 1-element run in A is already "sorted".\n
\t  // Make successively longer sorted runs of length 2, 4, 8, 16... until whole array is sorted.\n
\t  for (width = 1; width &lt; n; width = 2 * width)\n
\t    {\n
\t\t      // Array A is full of runs of length width.\n
\t\t      for (i = 0; i &lt; n; i = i + 2 * width)\n
\t\t        {\n
\t\t\t          // Merge two runs: A[i:i+width-1] and A[i+width:i+2*width-1] to B[]\n
\t\t\t          // or copy A[i:n-1] to B[] ( if(i+width >= n) )\n
\t\t\t          BottomUpMerge(A, i, min(i+width, n), min(i+2*width, n), B);\n
\t\t        }\n
\t\t      // Now work array B is full of runs of length 2*width.\n
\t\t      // Copy array B to array A for next iteration.\n
\t\t      // A more efficient implementation would swap the roles of A and B.\n
\t\t      CopyArray(B, A, n);\n
\t\t      // Now array A is full of runs of length 2*width.\n
 \t   }\n
}\n

\t//  Left run is A[iLeft :iRight-1].\n
\t// Right run is A[iRight:iEnd-1  ].\n
\tBottomUpMerge(A[], iLeft, iRight, iEnd, B[])\n
{\n
\t    i = iLeft, j = iRight;\n
\t    // While there are elements in the left or right runs...\n
\t    for (k = iLeft; k &lt; iEnd; k++) {\n
\t\t        // If left run head exists and is &lt;= existing right run head.\n
 \t\t       if (i &lt; iRight &amp;&amp; (j >= iEnd || A[i] &lt;= A[j])) {\n
\t\t\t            B[k] = A[i];\n
\t\t\t            i = i + 1;\n
\t\t        } else {\n
\t\t\t            B[k] = A[j];\n
\t\t\t            j = j + 1;\n
\t\t        }\n
\t    }\n
}\n

void CopyArray(B[], A[], n){\n
\t    for(i = 0; i &lt; n; i++)\n
\t\t        A[i] = B[i];\n
}\n
        </item>
</string-array>
<string-array name="quick_sort_">
        <item name = "definition"> Quicksort (sometimes called partition-exchange sort) is an
            efficient sorting algorithm, serving as a systematic method for placing the elements of
            an array in order. Developed by Tony Hoare in 1959, with his work published in 1961, it
            is still a commonly used algorithm for sorting. When implemented well, it can be about
            two or three times faster than its main competitors, merge sort and heapsort.</item>
        <item name = "code">
            public class MyQuickSort {\n
\n
\t    private int array[];\n
\t    private int length;\n
\t
\t    public void sort(int[] inputArr) {\n
\t
 \t\t       if (inputArr == null || inputArr.length == 0) {\n
\t\t            return;\n
 \t       }\n
\t\t        this.array = inputArr;\n
\t\t        length = inputArr.length;\n
\t\t        quickSort(0, length - 1);\n
\t    }\n
\n
\t    private void quickSort(int lowerIndex, int higherIndex) {\n
\n
\t\t        int i = lowerIndex;\n
\t\t        int j = higherIndex;\n
\t\t        // calculate pivot number, I am taking pivot as middle index number\n
\t\t        int pivot = array[lowerIndex+(higherIndex-lowerIndex)/2];\n
\t\t        // Divide into two arrays\n
\t\t        while (i &lt;= j) {\n
\t\t            /**\n
\t\t\t             * In each iteration, we will identify a number from left side which\n
\t\t\t             * is greater then the pivot value, and also we will identify a number\n
\t\t\t             * from right side which is less then the pivot value. Once the search\n
\t\t\t             * is done, then we exchange both numbers.\n
\t\t\t             */\n
\t\t\t            while (array[i] &lt; pivot) {\n
\t\t\t\t                i++;\n
\t\t\t            }\n
\t\t\t            while (array[j] > pivot) {\n
 \t\t\t\t               j--;\n
\t\t\t            }\n
\t\t\t            if (i &lt;= j) {\n
\t\t\t\t                exchangeNumbers(i, j);\n
 \t\t\t\t               //move index to next position on both sides\n
 \t\t\t\t               i++;\n
 \t\t\t\t               j--;\n
 \t\t\t           }\n
  \t\t      }\n
        // call quickSort() method recursively\n
  \t\t      if (lowerIndex &lt; j)\n
   \t\t\t         quickSort(lowerIndex, j);\n
   \t\t     if (i &lt; higherIndex)\n
    \t\t\t        quickSort(i, higherIndex);\n
 \t\t   }\n
\n
\t\t    private void exchangeNumbers(int i, int j) {\n
\t\t\t        int temp = array[i];\n
\t\t\t        array[i] = array[j];\n
\t\t\t        array[j] = temp;\n
\t\t    }\n
\n
\t\t    public static void main(String a[]){\n
\n
 \t\t       MyQuickSort sorter = new MyQuickSort();\n
 \t\t       int[] input = {24,2,45,20,56,75,2,56,99,53,12};\n
  \t\t      sorter.sort(input);\n
  \t\t      for(int i:input){\n
  \t\t\t          System.out.print(i);\n
  \t\t\t          System.out.print(" ");\n
  \t\t      }\n
 \t   }\n
}
</item>
</string-array>
<string-array name="heap_sort_">
    <item name = "definition">  heapsort is a comparison-based sorting algorithm. Heapsort can
            be thought of as an improved selection sort: like that algorithm, it divides its input
            into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by
            extracting the largest element and moving that to the sorted region. The improvement
            consists of the use of a heap data structure rather than a linear-time search to find
            the maximum.</item>
    <item name = "code">public class HeapSort\n
{\n
\t    private static int N;\n
\t    /* Sort Function */\n
\t    public static void sort(int arr[])\n
\t    {\n
\t\t        heapify(arr);\n
\t\t        for (int i = N; i > 0; i--)\n
\t\t        {\n
\t\t\t            swap(arr,0, i);\n
\t\t\t            N = N-1;\n
\t\t\t            maxheap(arr, 0);\n
\t\t        }\n
\t    }\n
\t    /* Function to build a heap */\n
\t    public static void heapify(int arr[])\n
\t    {\n
\t\t        N = arr.length-1;\n
\t\t        for (int i = N/2; i >= 0; i--)\n
\t\t\t            maxheap(arr, i);\n
\t    }\n
 \t   /* Function to swap largest element in heap */\n
 \t   public static void maxheap(int arr[], int i)\n
 \t   {\n
 \t\t       int left = 2*i ;\n
 \t\t       int right = 2*i + 1;\n
 \t\t       int max = i;\n
 \t\t       if (left &lt;= N &amp;&amp; arr[left] > arr[i])\n
 \t\t\t           max = left;\n
  \t\t      if (right &lt;= N &amp;&amp; arr[right] > arr[max])\n
  \t\t\t          max = right;\n
\n
 \t\t       if (max != i)\n
  \t\t      {\n
  \t\t\t          swap(arr, i, max);\n
  \t\t\t          maxheap(arr, max);\n
  \t\t      }\n
  \t  }\n
  \t  /* Function to swap two numbers in an array */\n
  \t  public static void swap(int arr[], int i, int j)\n
  \t  {\n
  \t\t      int tmp = arr[i];\n
  \t\t      arr[i] = arr[j];\n
  \t\t      arr[j] = tmp;\n
  \t  }\n
  \t  /* Main method */\n
  \t  public static void main(String[] args)\n
  \t  {\n
  \t\t\      Scanner scan = new Scanner( System.in );\n
  \t\t      System.out.println("Heap Sort Test\n");\n
  \t\t      int n, i;\n
  \t\t      /* Accept number of elements */\n
  \t\t      System.out.println("Enter number of integer elements");\n
  \t\t      n = scan.nextInt();\n
  \t\t      /* Make array of n elements */\n
  \t\t      int arr[] = new int[ n ];\n
  \t\t      /* Accept elements */\n
  \t\t      System.out.println("\nEnter "+ n +" integer elements");\n
  \t\t      for (i = 0; i &lt; n; i++)\n
  \t\t\t          arr[i] = scan.nextInt();\n
  \t\t      /* Call method sort */\n
  \t\t      sort(arr);\n
  \t\t      /* Print sorted Array */\n
  \t\t      System.out.println("\nElements after sorting ");\n
  \t\t      for (i = 0; i &lt; n; i++)\n
  \t\t\t          System.out.print(arr[i]+" ");\n
  \t\t      System.out.println();\n
  \t  }\n
}</item>
</string-array>
<string-array name="bucket_sort_">
        <item name = "definition">
        Bucket sort, or bin sort, is a sorting algorithm that works by distributing the elements of
            an array into a number of buckets. Each bucket is then sorted individually, either using
            a different sorting algorithm, or by recursively applying the bucket sorting algorithm.
            It is a distribution sort, and is a cousin of radix sort in the most to least
            significant digit flavour. Bucket sort is a generalization of pigeonhole sort.
            Bucket sort can be implemented with comparisons and therefore can also be considered a
            comparison sort algorithm. The computational complexity estimates involve the number of
            buckets.

            Bucket sort works as follows:
            1.Set up an array of initially empty "buckets".
            2.Scatter: Go over the original array, putting each object in its bucket.
            3.Sort each non-empty bucket.
            4.Gather: Visit the buckets in order and put all elements back into the original array.
        </item>
        <item name = "code">public class BucketSort{\n
\n
\t   public static void sort(int[] a, int maxVal) {\n
\t\t      int [] bucket=new int[maxVal+1];\n
\n
\t\t      for (int i=0; i&lt;bucket.length; i++) {\n
\t\t\t         bucket[i]=0;\n
\t\t      }\n
\n
\t\t      for (int i=0; i&lt;a.length; i++) {\n
\t\t\t         bucket[a[i]]++;\n
\t\t      }\n
\n
\t\t      int outPos=0;\n
\t\t      for (int i=0; i&lt;bucket.length; i++) {\n
\t\t\t         for (int j=0; j&lt;bucket[i]; j++) {\n
\t\t\t\t            a[outPos++]=i;\n
\t\t\t         }\n
\t\t      }\n
\t   }\n
\n
\t   public static void main(String[] args) {\n
\t\t      int maxVal=5;\n
\t\t      int [] data= {5,3,0,2,4,1,0,5,2,3,1,4};\n
\n
\t\t      System.out.println("Before: " + Arrays.toString(data));\n
\t\t      sort(data,maxVal);\n
\t\t      System.out.println("After:  " + Arrays.toString(data));\n
\t   }\n
}
        </item>
</string-array>
<string-array name="counting_sort_">
        <item name = "definition">
            Counting sort is an algorithm for sorting a collection of objects according to keys
            that are small integers; that is, it is an integer sorting algorithm. It operates by
            counting the number of objects that have each distinct key value, and using arithmetic
            on those counts to determine the positions of each key value in the output sequence.
            Its running time is linear in the number of items and the difference between the maximum
            and minimum key values, so it is only suitable for direct use in situations where the
            variation in keys is not significantly greater than the number of items. However, it is
            often used as a subroutine in another sorting algorithm, radix sort, that can handle
            larger keys more efficiently.
        </item>
        <item name ="code">
                int[] countingSort(int[] a, int k) {\n
\t        int c[] = new int[k];\n
\t        for (int i = 0; i &lt; a.length; i++)\n
\t\t            c[a[i]]++;\n
\t        for (int i = 1; i &lt; k; i++)\n
\t\t            c[i] += c[i-1];\n
\t        int b[] = new int[a.length];\n
\t        for (int i = a.length-1; i >= 0; i--)\n
\t\t            b[--c[a[i]]] = a[i];\n
\t        return b;\n
    }\n
        </item>
</string-array>

<string-array name="bit_manipulation_">
        <item name ="definition">Majority Element II
\n
Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.
\n
Hint:\n

How many majority elements could it possibly have?\n
Do you have a better hint? Suggest it!\n

        </item>
        <item name ="code">
public List&lt;Integer&gt; majorityElement(int[] nums) {\n
\t        List&lt;Integer&gt; rt = new ArrayList&lt;Integer&gt;();\n
\t        if (nums == null || nums.length == 0) {\n
\t\t            return rt;\n
\t        }\n
\t        int m1 = nums[0];\n
\t        int m2 = 0;\n
\t        int c1 = 1;\n
\t        int c2 = 0;\n
\t        for (int i = 1; i &lt; nums.length; i++) {\n
\t\t            int x = nums[i];\n
\t\t            if (x == m1) {\n
\t\t\t                c1++;\n
\t\t            } else if (x == m2) {\n
\t\t\t                c2++;\n
\t\t            } else if (c1 == 0) {\n
\t\t\t                m1 = x;\n
\t\t\t                c1 = 1;\n
\t\t            } else if (c2 == 0) {\n
\t\t\t                m2 = x;\n
\t\t\t                c2 = 1;\n
\t\t            } else {\n
\t\t\t                c1--;\n
\t\t\t                c2--;\n
\t\t            }\n
\t        }\n
\t        c1 = 0;\n
\t        c2 = 0;\n
\t        for (int i = 0; i &lt; nums.length; i++) {\n
\t\t            if (m1 == nums[i]) {\n
\t\t\t                c1++;\n
\t\t            } else if (m2 == nums[i]) {\n
\t\t\t                c2++;\n
\t\t            }\n
\t        }\n
\t        if (c1 &gt; nums.length / 3) {\n
\t\t            rt.add(m1);\n
\t        }\n
\t        if (c2 &gt; nums.length / 3) {\n
\t\t            rt.add(m2);\n
\t        }\n
\t        return rt;\n
    }\n
        </item>
</string-array>

<string-array name="strstr_">
        <item name="definition">
            strstr (a.k.a find sub string), is a useful function in string operation.
You task is to implement this function.
\n
For a given source string and a target string,
you should output the "first" index(from 0) of target string in source string.
\n
If target is not exist in source, just return -1.
\n
Example\n
If source="source" and target="target", return -1.
\n
If source="abcdabcdefg" and target="bcd", return 1.
\n
Challenge
O(n) time.
\n
Clarification
Do I need to implement KMP Algorithm in an interview?
\n
                the interviewer just want to test your basic implementation ability.
        </item>
        <item name="code">
/**\n
 * http://www.jiuzhang.com//solutions/implement-strstr\n
 */\n
class Solution {\n
\t    /**\n
\t     * Returns a index to the first occurrence of target in source,\n
\t     * or -1  if target is not part of source.\n
\t     * @param source string to be scanned.\n
\t     * @param target string containing the sequence of characters to match.\n
\t     */\n
\t    public int strStr(String source, String target) {\n
\t\t        if (source == null || target == null) {\n
\t\t            return -1;\n
\t        }\n

\t        int i, j;\n
\t        for (i = 0; i &lt; source.length() - target.length() + 1; i++) {\n
\t\t            for (j = 0; j &lt; target.length(); j++) {\n
\t\t\t                if (source.charAt(i + j) != target.charAt(j)) {\n
\t\t\t\t                    break;\n
\t\t\t                } //if\n
\t\t            } //for j\n
\t\t            if (j == target.length()) {\n
\t\t\t                return i;\n
\t\t            }\n
\t\t        } //for i\n
\n
\t\t        // did not find the target\n
\t\t        return -1;\n
\t    }\n
}\n
        </item>
</string-array>

<string-array name="two_strings_are_anagrams_">
    <item name="definition">
Write a method anagram(s,t) to decide if two strings are anagrams or not.
\n
Example\n
Given s="abcd", t="dcab", return true.
\n
Challenge
O(n) time, O(1) extra space
    </item>
    <item name="code">
final static int LETTERS_LEN = 256;	\n

	public static boolean isAnagram(String s1, String s2) {\n
\t		if (s1 == null || s2 == null)\n
\t\t			return false;\n
\t		int len = s1.length();\n
\t		if (len != s2.length() || len &lt; 2)\n
\t\t			return false;\n

\t		int[] letters = new int[LETTERS_LEN];\n

\t		for (int i = 0; i &lt; len; i++) {\n
\t\t			letters[s1.charAt(i)]++;\n
\t\t			letters[s2.charAt(i)]--;\n
\t		}\n

\t		for (int i = 0; i &lt; LETTERS_LEN; i++) {\n
\t\t			if (letters[i] != 0) {\n
\t\t\t				return false;\n
\t\t			}\n
\t		}\n
\t		return true;\n
	}\n
    </item>
</string-array>

<string-array name="compare_strings_">
    <item name="definition">
Compare two strings A and B, determine whether A contains all of the characters in B.
\n
The characters in string A and B are all Upper Case letters.
\n
Example\n
For A = "ABCD", B = "ABC", return true.
\n
For A = "ABCD" B = "AABC", return false.
    </item>
    <item name="code">
 public int compareVersion(String version1, String version2) {\n\t
 \t   String[] arr1 = version1.split("\\.");\n
 \t   String[] arr2 = version2.split("\\.");\n

 \t   int i=0;\n
 \t   while(i&lt;arr1.length || i&lt;arr2.length){\n
 \t\t       if(i&lt;arr1.length &amp;&amp; i&lt;arr2.length){\n
 \t\t\t           if(Integer.parseInt(arr1[i]) &lt; Integer.parseInt(arr2[i])){\n
 \t\t\t\t               return -1;\n
 \t\t\t           }else if(Integer.parseInt(arr1[i]) > Integer.parseInt(arr2[i])){\n
 \t\t\t\t               return 1;\n
 \t\t\t           }\n
 \t\t       } else if(i&lt;arr1.length){\n
 \t\t\t           if(Integer.parseInt(arr1[i]) != 0){\n
 \t\t\t\t               return 1;\n
 \t\t\t           }\n
 \t\t       } else if(i&lt;arr2.length){\n
 \t\t\t          if(Integer.parseInt(arr2[i]) != 0){\n
 \t\t\t\t               return -1;\n
 \t\t\t           }\n
 \t\t       }\n
 \t\t       i++;\n
 \t   }\n
 \t   return 0;\n
}\n
    </item>
</string-array>

<string-array name = "anagrams_">
    <item name="definition">
Given an array of strings, return all groups of strings that are anagrams.
\n
Example\n
Given ["lint", "intl", "inlt", "code"], return ["lint", "inlt", "intl"].
\n
Given ["ab", "ba", "cd", "dc", "e"], return ["ab", "ba", "cd", "dc"].\n
Note\n
All inputs will be in lower-case
    </item>
    <item name="code">

public class Solution {\n
\t    public List&lt;String&gt; anagrams(String[] strs) {\n
\t\t        HashMap&lt;String, LinkedList&lt;String&gt;&gt; dict = new HashMap&lt;&gt;();\n
\t\t        for (int i = 0; i &lt; strs.length; i++) {\n
\t\t\t            String s = strs[i];\n
\t\t\t            char[] chars = s.toCharArray();\n
\t\t\t            Arrays.sort(chars);\n
\t\t\t            String sortedString = String.valueOf(chars);\n
\t\t\t            if (dict.containsKey(sortedString)) {\n
\t\t\t\t                dict.get(sortedString).add(s);\n
\t\t\t            } else {\n
\t\t\t\t                LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();\n
\t\t\t\t                list.add(s);\n
\t\t\t\t                dict.put(sortedString, list);\n
\t\t\t            }\n
\t\t        }\n
\t\t        List&lt;String> ret = new LinkedList&lt;&gt;();\n
\t\t        for (LinkedList&lt;String&gt; list : dict.values()) {\n
\t\t\t            if (list.size() &gt; 1)\n
\t\t\t                ret.addAll(list);\n
\t\t        }\n
\t\t        return ret;\n
\t    }\n
}\n
    </item>
</string-array>

<string-array name="longest_common_substring_">
<item name="definition">
Given two strings, find the longest common substring.
Return the length of it.\n
\n
Example\n
Given A="ABCD", B="CBCE", return 2.\n
Note\n
The characters in substring should occur continuously in original string.\n
This is different with subsequence.
</item>
<item name="code">
    public class Solution {\n
\t    /**\n
\t     * @param A, B: Two string.\n
\t     * @return: the length of the longest common substring.\n
\t     */\n
\t    public int longestCommonSubstring(String A, String B) {\n
\t\t        // write your code here\n
\t\t        int maxlen = 0;\n
\t\t        int xlen = A.length();\n
\t\t        int ylen = B.length();\n
\t\t        for(int i = 0; i &lt; xlen; ++i)\n
\t\t	    {\n
\t\t\t		    for(int j = 0; j &lt; ylen; ++j)\n
\t\t\t		    {\n
\t\t\t\t			    int len = 0;\n
\t\t\t\t                while (i + len &lt; xlen &amp;&amp; j + len &lt; ylen &amp;&amp;
\t\t\t\t                    A.charAt(i + len) == B.charAt(j + len))\n
\t\t\t\t\t                        len ++;\n
\t\t\t\t			    if(len > maxlen)\n
\t\t\t\t\t				    maxlen = len;\n
\t\t\t		    }\n
\t\t	    }\n
\t\t        return maxlen;\n
\t    }\n
}
</item>
</string-array>

<string-array name="remove_element_">
    <item name="definition">
    Given an array and a value, remove all occurrences of that value in place and return the new length.
        The order of elements can be changed, and the elements after the new length do not matter.\n
        Example\n
        Given an array [0,4,4,0,0,2,4,4], value=4\n
\n
        return 4 and front four elements of the array is [0,0,0,2]\n
    </item>
    <item name="code">
        public class Solution {\n
\t    public int removeElement(int[] A, int elem) {\n
\t\t        int count = 0;\n
\t\t        for(int i=0; i&lt;A.length; i++){\n
\t\t\t            if(A[i] != elem){\n
\t\t\t\t                A[count] = A[i];\n
\t\t\t\t                count++;\n
\t\t\t            }\n
\t\t        }\n
\t\t        return count;\n
\t    }\n
}\n
    </item>
</string-array>
<string-array name="zero_sum_subarray_">
<item name="definition">
    Given an integer array, find a subarray where the sum of numbers is zero.\n
    Your code  should return the index of the first number and the index of the last number.
    </item>
    <item name="code">
        public class Solution {\n
    /**\n
     * @param nums: A list of integers\n
     * @return: A integer indicate the sum of max subarray\n
     */\n
\t    public int maxSubArray(ArrayList&lt;Integer&gt; nums) {\n
\t\t        // -1 is not proper for illegal input\n
\t\t        if (nums == null || nums.isEmpty()) return -1;\n
\n
\t\t        int sum = 0, maxSub = Integer.MIN_VALUE;\n
\t\t        for (int num : nums) {\n
\t\t\t            // drop negtive sum\n
\t\t\t            sum = Math.max(sum, 0);\n
\t\t\t            sum += num;\n
\t\t\t            // update maxSub\n
\t\t\t            maxSub = Math.max(maxSub, sum);\n
\t\t        }\n
\t\t        return maxSub;\n
\t    }\n
}
    </item>
</string-array>

<string-array name="subarray_sum_k_">
    <item name="definition">
Given an nonnegative integer array, find a subarray where the sum of numbers is k.
Your code should return the index of the first number and the index of the last number.
\n
Example\n
Given [1, 4, 20, 3, 10, 5], sum k = 33, return [2, 4].
    </item>
    <item name="code">
          public class Solution {\n
\t    public int maxSubArrayLen(int[] nums, int k) {\n
\t\t        if (nums==null || nums.length==0) return 0;\n
\t\t        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();\n
\t\t        map.put(0, -1);\n
\t\t        int sum = 0;\n
\t\t        int maxLen = Integer.MIN_VALUE;\n
\t\t        for (int i=0; i&lt;nums.length; i++) {\n
\t\t\t            sum += nums[i];\n
\t\t\t            if (!map.containsKey(sum)) {\n
\t\t\t\t                map.put(sum, i);\n
\t\t\t            }\n
\t\t\t            if (map.containsKey(sum-k)) {\n
\t\t\t\t                int index = map.get(sum-k);\n
\t\t\t\t                maxLen = Math.max(maxLen, i-index);\n
\t\t\t            }\n
\t\t        }\n
\t\t        return maxLen==Integer.MIN_VALUE? 0 : maxLen;\n
\t    }\n
}
    </item>
</string-array>

<string-array name="subarray_sum_closest_">
    <item name="definition">
Given an integer array, find a subarray with sum closest to zero. Return the indexes of the first number and last number.
    </item>
    <item name="code">
 class Pair {\n
\t    int sum;\n
\t    int index;\n
\t    public Pair(int s, int i) {\n
\t\t        sum = s;\n
\t\t        index = i;\n
\t    }\n
}\n

public class Solution {\n
    /**\n
     * @param nums: A list of integers\n
     * @return: A list of integers includes the index of the first number\n
     *          and the index of the last number\n
     */\n
\t    public int[] subarraySumClosest(int[] nums) {\n
\t\t        int[] res = new int[2];\n
\t\t        if (nums == null || nums.length == 0) {\n
\t\t\t            return res;\n
\t\t        }\n
\n
\t\t        int len = nums.length;\n
\t\t        if(len == 1) {\n
\t\t\t            res[0] = res[1] = 0;\n
\t\t\t            return res;\n
\t\t        }\n
\t\t        Pair[] sums = new Pair[len+1];\n
\t\t        int prev = 0;\n
\t\t        sums[0] = new Pair(0, 0);\n
\t\t        for (int i = 1; i &lt;= len; i++) {\n
\t\t\t            sums[i] = new Pair(prev + nums[i-1], i);\n
\t\t\t            prev = sums[i].sum;\n
\t\t        }\n
\t\t        Arrays.sort(sums, new Comparator&lt;Pair&gt;() {\n
\t\t\t           public int compare(Pair a, Pair b) {\n
\t\t\t\t               return a.sum - b.sum;\n
\t\t\t           }\n
\t\t        });\n
\t\t        int ans = Integer.MAX_VALUE;\n
\t\t        for (int i = 1; i &lt;= len; i++) {\n
\n
\t\t\t            if (ans > sums[i].sum - sums[i-1].sum) {\n
\t\t\t\t                ans = sums[i].sum - sums[i-1].sum;\n
\t\t\t\t                int[] temp = new int[]{sums[i].index - 1, sums[i - 1].index - 1};\n
\t\t\t\t                Arrays.sort(temp);\n
\t\t\t\t                res[0] = temp[0] + 1;\n
\t\t\t\t                res[1] = temp[1];\n
\t\t\t            }\n
\t\t        }\n
\t\t        return res;\n
\t    }\n
}
    </item>
</string-array>

<string-array name="product_of_array_exclude_itself_">
    <item name="definition">
Given an integers array A.
\n
Define B[i] = A[0] * ... * A[i-1] * A[i+1] * ... * A[n-1], calculate B WITHOUT divide operation.
\n
Example\n
For A=[1, 2, 3], return [6, 3, 2].
    </item>
    <item name="code">
                public int[] productExceptSelf(int[] nums) {\n
\t    int[] result = new int[nums.length];\n
\t    int[] t1 = new int[nums.length];\n
\t    int[] t2 = new int[nums.length];\n
\t    t1[0]=1;\n
\t    t2[nums.length-1]=1;\n
\n
\t    //scan from left to right\n
\t    for(int i=0; i&lt;nums.length-1; i++){\n
\t\t        t1[i+1] = nums[i] * t1[i];\n
\t    }\n
\n
\t    //scan from right to left\n
\t    for(int i=nums.length-1; i&gt;0; i--){\n
\t\t        t2[i-1] = t2[i] * nums[i];\n
\t    }\n
\n
\t    //multiply\n
\t    for(int i=0; i&lt;nums.length; i++){\n
\t\t        result[i] = t1[i] * t2[i];\n
\t    }\n
\t    return result;\n
}
    </item>
</string-array>

<string-array name="partition_array_">
<item name="definition">
Given an array nums of integers and an int k, partition the array
(i.e move the elements in "nums") such that:
\n
All elements &lt; k are moved to the left\n
All elements &gt;= k are moved to the right\n
Return the partitioning index, i.e the first index i nums[i] &gt;= k.
\n
Example\n
If nums=[3,2,2,1] and k=2, a valid answer is 1.\n

Note\n
You should do really partition in array nums instead of just
counting the numbers of integers smaller than k.
\n
If all elements in nums are smaller than k, then return nums.length
\n
Challenge\n
Can you partition the array in-place and in O(n)?
</item>
<item name="code">
        public class Solution {\n
	/**\n
     *@param nums: The integer array you should partition\n
     *@param k: As description\n
     *return: The index after partition\n
     */\n
\t    public int partitionArray(int[] nums, int k) {\n
\t\t	    //write your code here\n
\t\t	    if(nums == null || nums.length == 0){\n
\t\t\t            return 0;\n
\t\t        }\n
\t\t        // //dummy number\n
\t\t        // nums.add(k);\n
\n
\t\t        int i = 0;\n
\t\t        int j = nums.length - 1;\n
\t\t	    for(; i &lt;= j; i++){\n
\t\t\t	        if(nums[i]&lt; k){\n
\t\t\t\t	            continue;\n
\t\t\t	        }\n
\n
\t\t\t	        while(j >= i &amp;&amp; nums[j] &gt;= k){\n
\t\t\t\t	            j --;\n
\t\t\t	        }//while\n
\n
\t\t\t	        //i points to a number &gt;= k\n
\t\t\t	        //j points to a number &lt; k\n
\t\t\t	        //swap i and j\n
\t\t\t	        if(j >= 0 &amp;&amp; i &lt; j){\n
\t\t\t\t	            int tmp = nums[i];\n
\t\t\t\t    	        nums[i] = nums[j];\n
\t\t\t\t    	        nums[j] = tmp;\n
\t\t\t\t    	        j --;\n
\t\t\t	        }\n
\n
\t\t	    }//for\n
\n
\t\t	   // nums.remove(j + 1);\n
\t\t	    return j + 1;\n
\t    }//partitionArray\n
}
</item>
</string-array>

<string-array name="first_missing_positive_">
<item name="definition">
Given an unsorted integer array, find the first missing positive integer.
\n
For example,\n
Given [1,2,0] return 3,\n
and [3,4,-1,1] return 2.
</item>
<item name="code">
int firstMissingPositiveAnd0(int A[]) {\n
\t	int n = A.length;\n
\t	for (int i = 0; i &lt; n; i++) {\n
\t\t		// when the ith element is not i\n
\t\t		while (A[i] != i) {\n
\t\t\t			// no need to swap when ith element is out of range [0,n]\n
\t\t\t			if (A[i] &lt; 0 || A[i] >= n)\n
\t\t\t\t				break;\n
\n
\t\t\t			//handle duplicate elements\n
\t\t\t			if(A[i]==A[A[i]])\n
\t\t\t\t                    		break;\n
\t\t\t			// swap elements\n
\t\t\t			int temp = A[i];\n
\t\t\t			A[i] = A[temp];\n
\t\t\t			A[temp] = temp;\n
\t\t		}\n
\t	}\n
\t	for (int i = 0; i &lt; n; i++) {\n
\t\t		if (A[i] != i)\n
\t\t\t			return i;\n
\t	}\n
\t	return n;\n
}\n
</item>
</string-array>

<string-array name="two_sum_">
<item name="definition">
Given an array of integers, find two numbers such that they add up to a specific target number.
\n
The function twoSum should return indices of the two numbers
such that they add up to the target, where index1 must be less than index2.
Please note that your returned answers (both index1 and index2) are not zero-based.
\n
You may assume that each input would have exactly one solution.
\n
Input: numbers={2, 7, 11, 15}, target=9\n
Output: index1=1, index2=2
</item>
<item name="code">
public static int[] twoSum(int[] numbers, int target) {\n
\t	int[] ret = new int[2];\n
\t	for (int i = 0; i &lt; numbers.length; i++) {\n
\t\t		for (int j = i + 1; j &lt; numbers.length; j++) {\n
\t\t\t			if (numbers[i] + numbers[j] == target) {\n
\t\t\t\t				ret[0] = i + 1;\n
\t\t\t\t				ret[1] = j + 1;\n
\t\t\t			}\n
\t\t		}\n
\t	}\n
\t	return ret;\n
}
</item>
</string-array>

<string-array name="three_sum_">
<item name="definition">
Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0?
Find all unique triplets in the array which gives the sum of zero.
\n
Example\n
For example, given array S = {-1 0 1 2 -1 -4}, A solution set is:
\n
(-1, 0, 1)\n
(-1, -1, 2)\n
Note\n
Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)
\n
The solution set must not contain duplicate triplets.
</item>
<item name="code">
public class Solution {\n
\t    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(int[] num) {\n
\t\t        //sort array\n
\t\t        Arrays.sort(num);\n
\t\t        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();\n
\t\t        ArrayList&lt;Integer&gt; each = new ArrayList&lt;Integer&gt;();\n
\t\t        for(int i=0; i&lt;num.length; i++){\n
\t\t\t            if(num[i] &gt; 0) break;\n
\n
\t\t\t            for(int j=i+1; j&lt;num.length; j++){\n
\t\t\t\t                if(num[i] + num[j] &gt; 0 &amp;&amp; num[j] &gt; 0) break;\n
\n
\t\t\t\t               for(int k=j+1; k&lt;num.length; k++){\n
\t\t\t\t\t                  if(num[i] + num[j] + num[k] == 0) {\n
\t\t\t\t\t\t                      each.add(num[i]);\n
\t\t\t\t\t\t                      each.add(num[j]);\n
\t\t\t\t\t\t                      each.add(num[k]);\n
\t\t\t\t\t\t                      result.add(each);\n
\t\t\t\t\t\t                      each.clear();\n
\t\t\t\t\t                  }\n
\t\t\t\t                }\n
\t\t\t            }\n
\t\t        }\n
\t\t        return result;\n
\t    }\n
}
</item>
</string-array>

<string-array name="three_sum_closest_">
<item name="definition">
Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.
\n
    For example, given array S = {-1 2 1 -4}, and target = 1.
\n
    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
</item>
<item name="code">
public int threeSumClosest(int[] nums, int target) {\n
\t    int min = Integer.MAX_VALUE;\n
\t	  int result = 0;\n
\n
\t	Arrays.sort(nums);\n
\n
\t	for (int i = 0; i &lt; nums.length; i++) {\n
\t\t		int j = i + 1;\n
\t\t		int k = nums.length - 1;\n
\t\t		while (j &lt; k) {\n
\t\t\t			int sum = nums[i] + nums[j] + nums[k];\n
\t\t\t			int diff = Math.abs(sum - target);\n
\n
\t\t\t			if(diff == 0) return sum;\n
\n
\t\t\t			if (diff &lt; min) {\n
\t\t\t\t				min = diff;\n
\t\t\t\t				result = sum;\n
\t\t\t			}\n
\t\t\t			if (sum &lt;= target) {\n
\t\t\t\t				j++;\n
\t\t\t			} else {\n
\t\t\t\t				k--;\n
\t\t\t			}\n
\t\t		}\n
\t	}\n
\n
\t	return result;\n
}
</item>
</string-array>

<string-array name="remove_duplicates_from_sorted_array_">
<item name="definition">
Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.
\n
Do not allocate extra space for another array, you must do this in place with constant memory.
\n
For example,\n
Given input array A = [1,1,2],
\n
Your function should return length = 2, and A is now [1,2].
</item>
<item name="code">
/**\n
 *\n
 * Remove Duplicates from Sorted Array\n
 *\n
 * Given a sorted array, remove the duplicates in place such that each element appear\n
 * only once and return the new length.\n
 *\n
 * Do not allocate extra space for another array, you must do this in place with\n
 * constant memory.\n
 *\n
 * For example, Given input array A = [1,1,2],\n
 *\n
 * Your function should return length = 2, and A is now [1,2].\n
 *\n
 */\n
public class S26 {\n
\n
\t	public static void main(String[] args) {\n
\t\t		int[] A = {1, 1, 2};\n
\t\t		System.out.println(removeDuplicates(A));\n
\t	}\n
\n
\t	public static int removeDuplicates(int[] A) {\n
\t\t		int len = A.length;\n
\t\t        if(len &lt; 2){\n
\t\t\t        	return len;\n
\t\t        }\n
\n
\t\t        int i = 0, j = 1;\n
\t\t        while(i&lt;len &amp;&amp; j&lt;len){\n
\t\t\t        	if(A[i] == A[j]){\n
\t\t\t\t        		j++;\n
\t\t\t        	}else{\n
\t\t\t\t        		i++;\n
\t\t\t\t        		A[i] = A[j];\n
\t\t\t\t        		j++;\n
\t\t\t        	}\n
\t\t        }\n
        //\n
\t\t        return i+1;\n
\t    }\n
}
</item>
</string-array>

<string-array name="remove_duplicates_from_sorted_array_ii_">
<item name="definition">
Follow up for "Remove Duplicates":
What if duplicates are allowed at most twice?
\n
For example,\n
Given sorted array A = [1,1,1,2,2,3],
\n
Your function should return length = 5, and A is now [1,1,2,2,3].
Example\n
</item>
<item name="code">
public class Solution {\n
\t    public int removeDuplicates(int[] A) {\n
\t\t        if(A == null || A.length == 0)\n
\t\t\t            return 0;\n
\t\t        int pre = A[0];\n
\t\t        boolean flag = false;\n
\t\t        int count = 0;\n
\t\t        for(int i=1; i&lt;A.length; i++){\n
\t\t\t            int curr = A[i];\n
\t\t\t            if(curr == pre){\n
\t\t\t\t                if(!flag){\n
\t\t\t\t\t                	flag = true;\n
\t\t\t\t\t                    continue;\n
\t\t\t\t                }else{\n
\t\t\t\t\t                    count++;\n
\t\t\t\t                }\n
\t\t\t            }else{\n
\t\t\t\t                pre = curr;\n
\t\t\t\t                flag = false;\n
\t\t\t            }\n
\t\t        }\n
\t\t        return A.length - count;\n
\t    }\n
}
</item>
</string-array>

<string-array name="merge_sorted_array_">
<item name="definition">
Merge two given sorted integer array A and B into a new sorted integer array.
\n
Example\n
A=[1,2,3,4]
\n
B=[2,4,5,6]
\n
return [1,2,2,3,4,4,5,6]
\n
Challenge\n
How can you optimize your algorithm if one array is very large and the other is very small?
</item>
<item name="code">
class Solution {
    /**\n
     * @param A: sorted integer array A which has m elements,\n
     *           but size of A is m+n\n
     * @param B: sorted integer array B which has n elements\n
     * @return: void\n
     */\n
\t    public void mergeSortedArray(int[] A, int m, int[] B, int n) {\n
\t\t        int i = m-1, j = n-1, index = m + n - 1;\n
\t\t        while (i >= 0 &amp;&amp; j >= 0) {\n
\t\t\t            if (A[i] > B[j]) {\n
\t\t\t\t                A[index--] = A[i--];\n
\t\t\t            } else {\n
\t\t\t\t                A[index--] = B[j--];\n
\t\t\t            }\n
\t\t        }\n
\t\t        while (i >= 0) {\n
\t\t\t            A[index--] = A[i--];\n
\t\t        }\n
\t\t        while (j >= 0) {\n
\t\t\t            A[index--] = B[j--];\n
\t\t        }\n
\t    }\n
}\n
</item>
</string-array>

<string-array name="merge_sorted_array_ii_">
<item name="definition">
Given two sorted integer arrays A and B, merge B into A as one sorted array.
\n
Note\n
You may assume that A has enough space (size that is greater or equal to m + n) to hold additional elements from B. The number of elements initialized in A and B are mand n respectively.
\n
Example\n
A = [1, 2, 3, empty, empty] B = [4,5]
\n
After merge, A will be filled as [1,2,3,4,5]
</item>
<item name="code">
class Solution {\n
    /**\n
     * @param A: sorted integer array A which has m elements,\n
     *           but size of A is m+n\n
     * @param B: sorted integer array B which has n elements\n
     * @return: void\n
     */\n
\t    public void mergeSortedArray(int A[], int m, int B[], int n) {\n
\t\t        int index = n + m;\n
\n
\t\t        while (m > 0 &amp;&amp; n > 0) {\n
\t\t\t            if (A[m - 1] > B[n - 1]) {\n
\t\t\t\t                A[--index] = A[--m];\n
\t\t\t            } else {\n
\t\t\t\t                A[--index] = B[--n];\n
\t\t\t            }\n
\t\t        }\n
\t\t        while (n > 0) {\n
\t\t\t            A[--index] = B[--n];\n
\t\t        }\n
\t\t        while (m > 0) {\n
\t\t\t            A[--index] = A[--m];\n
\t\t        }\n
\t    }\n
};
</item>
</string-array>

<string-array name="binary_search_">
<item name="definition">
Binary search is a famous question in algorithm.
\n
For a given sorted array (ascending order) and a target number, find the first index of this number in O(log n) time complexity.
\n
If the target number does not exist in the array, return -1.
\n
Example\n
If the array is [1, 2, 3, 3, 4, 5, 10], for given target 3, return 2.
\n
Challenge\n
If the count of numbers is bigger than MAXINT, can your code work properly?
</item>
<item name="code">
    class Solution {\n
    /**\n
     * @param nums: The integer array.\n
     * @param target: Target to find.\n
     * @return: The first position of target. Position starts from 0.\n
     */\n
\t    public int binarySearch(int[] nums, int target) {\n
\t\t        if (nums == null || nums.length == 0) {\n
\t\t\t            return -1;\n
\t\t        }\n
\n
\t\t        int start = 0;\n
\t\t        int end = nums.length - 1;\n
\t\t        int mid;\n
\t\t        while (start + 1 &lt; end) {\n
\t\t\t            mid = start + (end - start) / 2; // avoid overflow when (end + start)\n
\t\t\t            if (target &lt; nums[mid]) {\n
\t\t\t\t                end = mid;\n
\t\t\t            } else if (target > nums[mid]) {\n
\t\t\t\t                start = mid;\n
\t\t\t            } else {\n
\t\t\t\t                end = mid;\n
\t\t\t            }\n
\t\t        }\n
\n
\t\t        if (nums[start] == target) {\n
\t\t\t            return start;\n
\t\t        }\n
\t\t        if (nums[end] == target) {\n
\t\t\t            return end;\n
 \t\t       }\n
\n
\t\t        return -1;\n
\t    }\n
}\n
</item>
</string-array>

<string-array name="search_insert_position_">
<item name="definition">
Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
\n
You may assume no duplicates in the array.
\n
Example\n
[1,3,5,6], 5 → 2\n
[1,3,5,6], 2 → 1\n
[1,3,5,6], 7 → 4\n
[1,3,5,6], 0 → 0
</item>
<item name="code">
    public class Solution {\n
    /**\n
     * param A : an integer sorted array\n
     * param target :  an integer to be inserted\n
     * return : an integer\n
     */\n
\t    public int searchInsert(int[] A, int target) {\n
\t        if (A == null) {\n
\t\t            return -1;\n
\t\t        }\n
\t\t        if (A.length == 0) {\n
\t\t\t            return 0;\n
\t\t        }\n
\n
\t\t        int start = 0, end = A.length - 1;\n
\t\t        int mid;\n
\n
\t\t        while (start + 1 &lt; end) {\n
\t\t\t            mid = start + (end - start) / 2;\n
\t\t\t            if (A[mid] == target) {\n
\t\t\t\t                return mid; // no duplicates, if not `end = target;`\n
\t\t\t            } else if (A[mid] &lt; target) {\n
\t\t\t\t                start = mid;\n
\t\t\t            } else {\n
\t\t\t\t                end = mid;\n
\t\t\t            }\n
\t\t        }\n
\n
\t\t        if (A[start] >= target) {\n
\t\t\t            return start;\n
\t\t        } else if (A[end] >= target) {\n
\t\t\t            return end; // in most cases\n
\t\t        } else {\n
\t\t\t            return end + 1; // A[end] &lt; target;\n
\t\t        }\n
\t    }\n
}
</item>
</string-array>

<string-array name="search_for_a_range_">
<item name="definition">
Given a sorted array of integers, find the starting and ending position of a given target value.
\n
Your algorithm\'s runtime complexity must be in the order of O(log n).
\n
If the target is not found in the array, return [-1, -1].
\n
Example\n
Given [5, 7, 7, 8, 8, 10] and target value 8,\n
return [3, 4].
</item>
<item name="code">
public class Solution {\n
    /**\n
     *@param A : an integer sorted array\n
     *@param target :  an integer to be inserted\n
     *return : a list of length 2, [index1, index2]\n
     */\n
\t    public ArrayList searchRange(ArrayList A, int target) {\n
\t\t        ArrayList result = new ArrayList();\n
\t\t        int start, end, mid;\n
\t\t        result.add(-1);\n
\t\t        result.add(-1);\n
\n
\t\t        if (A == null || A.size() == 0) {\n
\t\t\t            return result;\n
\t\t        }\n
\n
\t\t        // search for left bound\n
\t\t        start = 0;\n
\t\t        end = A.size() - 1;\n
\t\t        while (start + 1 &lt; end) {\n
\t\t\t            mid = start + (end - start) / 2;\n
\t\t            if (A.get(mid) == target) {\n
\t\t\t                end = mid; // set end = mid to find the minimum mid\n
\t\t            } else if (A.get(mid) > target) {\n
\t\t\t                end = mid;\n
\t\t            } else {\n
\t\t\t                start = mid;\n
\t\t            }\n
\t        }\n
\t        if (A.get(start) == target) {\n
\t\t            result.set(0, start);\n
\t        } else if (A.get(end) == target) {\n
\t\t            result.set(0, end);\n
\t        } else {\n
\t\t            return result;\n
\t        }\n
\n
\t        // search for right bound\n
\t        start = 0;\n
\t        end = A.size() - 1;\n
\t        while (start + 1 &lt; end) {\n
\t\t            mid = start + (end - start) / 2;\n
\t\t            if (A.get(mid) == target) {\n
\t\t\t                start = mid; // set start = mid to find the maximum mid\n
\t\t            } else if (A.get(mid) > target) {\n
\t\t\t                end = mid;\n
\t\t            } else {\n
\t\t\t                start = mid;\n
\t\t            }\n
\t        }\n
\t        if (A.get(end) == target) {\n
\t\t            result.set(1, end);\n
\t        } else if (A.get(start) == target) {\n
\t\t            result.set(1, start);\n
\t        } else {\n
\t\t            return result;\n
\t        }\n
\n
\t        return result;\n
\t\t        // write your code here\n
\t    }\n
}
</item>
</string-array>
<string-array name="first_bad_version_">
<item name="definition">
The code base version is an integer start from 1 to n. One day, someone committed a bad version in the code case, so it caused this version and the following versions are all failed in the unit tests. Find the first bad version.
\n
You can call isBadVersion to help you determine which version is the first bad one. The details interface can be found in the code\'s annotation part.
</item>
<item name="code">
/**\n
 * public class VersionControl {\n
 *     public static boolean isBadVersion(int k);\n
 * }\n
 * you can use VersionControl.isBadVersion(k) to judge wether\n
 * the kth code version is bad or not.\n
*/\n
class Solution {\n
    /**\n
     * @param n: An integers.\n
     * @return: An integer which is the first bad version.\n
     */\n
\t    public int findFirstBadVersion(int n) {\n
\t\t        // write your code here\n
\t\t        if (n == 0) {\n
\t\t\t            return -1;\n
\t\t        }\n
\n
\t\t        int start = 1, end = n, mid;\n
\t\t        while (start + 1 &lt; end) {\n
\t\t\t            mid = start + (end - start)/2;\n
\t\t\t            if (VersionControl.isBadVersion(mid) == false) {\n
\t\t\t\t                start = mid;\n
\t\t\t            } else {\n
\t\t\t\t                end = mid;\n
\t\t\t            }\n
\t\t        }\n
\n
\t\t        if (VersionControl.isBadVersion(start) == true) {\n
\t\t\t            return start;\n
\t\t        } else if (VersionControl.isBadVersion(end) == true) {\n
\t\t\t            return end;\n
\t\t        } else {\n
\t\t\t            return -1; // not found\n
\t\t        }\n
\t    }\n
}
</item>
</string-array>

<string-array name="search_a_2d_matrix_">
<item name="definition">
Write an efficient algorithm that searches for a value in an m x n matrix.
\n
This matrix has the following properties:\n
    * Integers in each row are sorted from left to right.\n
    * The first integer of each row is greater than the last integer of the previous row.\n
Example\n
Consider the following matrix:
\n
[
    [1, 3, 5, 7],\n
    [10, 11, 16, 20],\n
    [23, 30, 34, 50]
]
\n
Given target = 3, return true.
\n
Challenge\n
O(log(n) + log(m)) time
</item>
<item name="code">
    public class Solution {\n
\t    public boolean searchMatrix(int[][] matrix, int target) {\n
\t\t        if(matrix==null || matrix.length==0 || matrix[0].length==0)\n
\t\t\t            return false;\n
\n
\t\t        int m = matrix.length;\n
\t\t        int n = matrix[0].length;\n
\n
\t\t        int start = 0;\n
\t\t        int end = m*n-1;\n
\n
\t\t        while(start&lt;=end){\n
\t\t\t            int mid=(start+end)/2;\n
\t\t\t            int midX=mid/n;\n
\t\t\t            int midY=mid%n;\n
\n
\t\t\t            if(matrix[midX][midY]==target)\n
\t\t\t\t                return true;\n

\t\t\t            if(matrix[midX][midY]&lt;target){\n
\t\t\t\t                start=mid+1;\n
\t\t\t            }else{\n
\t\t\t\t                end=mid-1;\n
\t\t\t            }\n
\t\t        }\n
\n
\t\t        return false;\n
\t    }\n
}
</item>
</string-array>
<string-array name="find_peak_element_">
<item name="definition">
There is an integer array which has the following features:
\n
    * The numbers in adjacent positions are different.
\n
    * A[0] &lt; A[1] &amp;&amp; A[A.length - 2] &gt; A[A.length - 1].
\n
We define a position P is a peek if A[P] &gt; A[P-1] &amp;&amp; A[P] &gt; A[P+1].
\n
Find a peak element in this array. Return the index of the peak.
\n
Note
The array may contains multiple peeks, find any of them.
\n
Example
[1, 2, 1, 3, 4, 5, 7, 6]
\n
return index 1 (which is number 2)  or 6 (which is number 7)
\n
Challenge\n
Time complexity O(logN)
</item>
<item name="code">
class Solution {\n
    /**\n
     * @param A: An integers array.\n
     * @return: return any of peek positions.\n
     */\n
\t    public int findPeak(int[] A) {\n
\t\t        // write your code here\n
\t\t        if (A == null) {\n
\t\t\t            return -1;\n
\t\t        }\n
\t\t        if (A.length == 0) {\n
\t\t\t            return 0;\n
\t\t        }\n
\n
\t\t        int start = 0, end = A.length - 1, mid = end / 2;\n
\t\t        while (start + 1 &lt; end) {\n
\t\t\t            mid = start + (end - start)/2;\n
\t\t\t            if (A[mid] &lt; A[mid - 1]) {\n
\t\t\t\t                end = mid;\n
\t\t\t            } else if (A[mid] &lt; A[mid + 1]) {\n
\t\t\t\t                start = mid;\n
\t\t\t            } else {\n
\t\t\t\t                return mid;\n
\t\t\t            }\n
\t\t        }\n
\n
\t\t        mid = (A[start] &gt; A[end]) ? start : end;\n
\t\t        return mid;\n
\t    }\n
}
</item>
</string-array>

<string-array name="search_in_rotated_sorted_array_">
<item name="definition">
There is an integer array which has the following features:
\n
    * The numbers in adjacent positions are different.
\n
    * A[0] &lt; A[1] &amp;&amp; A[A.length - 2] &gt; A[A.length - 1].
\n
We define a position P is a peek if A[P] &gt; A[P-1] &amp;&amp; A[P] &gt; A[P+1].
\n
Find a peak element in this array. Return the index of the peak.
\n
Note\n
The array may contains multiple peeks, find any of them.
\n
Example\n
[1, 2, 1, 3, 4, 5, 7, 6]
\n
return index 1 (which is number 2)  or 6 (which is number 7)
\n
Challenge\n
Time complexity O(logN)
</item>
<item name="code">
public class Solution {\n
    /**\n
     *@param A : an integer rotated sorted array\n
     *@param target :  an integer to be searched\n
     *return : an integer\n
     */\n
\t    public int search(int[] A, int target) {\n
\t\t        // write your code here\n
\t\t        if (A == null || A.length == 0) {\n
\t\t\t            return -1;\n
\t\t        }\n
\n
\t\t        int start = 0, end = A.length - 1, mid = 0;\n
\t\t        while (start + 1 &lt; end) {\n
\t\t\t            mid = start + (end - start)/2;\n
\t\t\t            if (A[mid] == target) {\n
\t\t\t\t                return mid;\n
\t\t\t            }\n
\t\t\t            if (A[start] &lt; A[mid]) {//part 1\n
\t\t\t\t                if (A[start] &lt;= target &amp;&amp; target &lt;= A[mid]) {\n
\t\t\t\t\t                    end = mid;\n
\t\t\t\t                } else {\n
\t\t\t\t\t                    start = mid;\n
\t\t\t\t                }\n
\t\t\t            } else { //part 2\n
\t\t\t\t                if (A[mid] &lt;= target &amp;&amp; target &lt;= A[end]) {\n
\t\t\t\t\t                    start = mid;\n
\t\t\t\t                } else {\n
\t\t\t\t\t                    end = mid;\n
\t\t\t\t                }\n
\t\t\t            }\n
\t\t        } // end while\n
\n
\t\t        if (A[start] == target) {\n
\t\t\t            return start;\n
\t\t        } else if (A[end] == target) {\n
\t\t\t            return end;\n
\t\t        } else {\n
\t\t\t            return -1; // not found\n
\t\t        }\n
\t    }\n
}
</item>
</string-array>
<string-array name="find_minimum_in_rotated_sorted_array_">
<item name="definition">
Suppose a sorted array is rotated at some pivot unknown to you beforehand.
\n
(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
\n
Find the minimum element.
\n
You may assume no duplicate exists in the array.
\n
Example\n
Given [4,5,6,7,0,1,2] return 0
</item>
<item name="code">
public class Solution {\n
    /**\n
     * @param num: a rotated sorted array\n
     * @return: the minimum number in the array\n
     */\n
\t    public int findMin(int[] nums) {\n
\t\t        if (nums == null || nums.length == 0) {\n
\t\t\t            return -1;\n
\t\t        }\n
\n
\t\t        int start = 0, end = nums.length - 1;\n
\t\t        int target = nums[nums.length - 1];\n
\n
\t\t        // find the first element &lt;= target\n
\t\t        while (start + 1 &lt; end) {\n
\t\t\t            int mid = start + (end - start) / 2;\n
\t\t\t            if (nums[mid] &lt;= target) {\n
\t\t\t\t                end = mid;\n
\t\t\t            } else {\n
\t\t\t\t                start = mid;\n
\t\t\t            }\n
\t\t        }\n
\t\t        if (nums[start] &lt;= target) {\n
\t\t\t            return nums[start];\n
\t\t        } else {\n
\t\t\t            return nums[end];\n
\t\t        }\n
\t    }\n
}
</item>
</string-array>
<string-array name="search_a_2d_matrix_ii_">
<item name="definition">
Write an efficient algorithm that searches for a value in an m x n matrix, return the occurrence of it.\n
This matrix has the following properties:\n
    * Integers in each row are sorted from left to right.\n
    * Integers in each column are sorted from up to bottom.\n
    * No duplicate integers in each row or column.\n
Example\n
Consider the following matrix:\n
[
    [1, 3, 5, 7],\n
    [2, 4, 7, 8],\n
    [3, 5, 9, 10]
]
Given target = 3, return 2.\n
Challenge\n
O(m+n) time and O(1) extra space
</item>
<item name="code">
public class Solution {\n
    /**\n
     * @param matrix: A list of lists of integers\n
     * @param: A number you want to search in the matrix\n
     * @return: An integer indicate the occurrence of target in the given matrix\n
     */\n
\t    public int searchMatrix(int[][] matrix, int target) {\n
\t\t        int occurence = 0;\n
\n
\t\t        if (matrix == null || matrix.length == 0) {\n
\t\t\t            return occurence;\n
\t\t        }\n
\t\t        if (matrix[0] == null || matrix[0].length == 0) {\n
\t\t\t            return occurence;\n
\t\t        }\n
\n
\t\t        int row = matrix.length - 1;\n
\t\t        int column = matrix[0].length - 1;\n
\t\t        int index_row = 0, index_column = column;\n
\t\t        int number;\n
\n
\t\t        if (target &lt; matrix[0][0] || target &gt; matrix[row][column]) {\n
\t\t\t            return occurence;\n
\t\t        }\n
\n
\t\t        while (index_row &lt; row + 1 &amp;&amp; index_column + 1 > 0) {\n
\t\t\t            number = matrix[index_row][index_column];\n
\t\t\t            if (target == number) {\n
\t\t\t\t                occurence++;\n
\t\t\t\t                index_column--;\n
\t\t\t            } else if (target &lt; number) {\n
\t\t\t\t                index_column--;\n
\t\t\t            } else if (target &gt; number) {\n
\t\t\t\t                index_row++;\n
\t\t\t            }\n
\t\t        }\n
\t\t        return occurence;\n
\t    }\n
}
</item>
</string-array>
<string-array name="median_of_two_sorted_arrays_">
<item name="definition">
There are two sorted arrays A and B of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
\n
Example\n
For A = [1,2,3,4,5,6] B = [2,3,4,5], the median is 3.5
\n
For A = [1,2,3] B = [4,5], the median is 3
\n
Challenge\n
Time Complexity O(logn)
</item>
<item name="code">
class Solution {\n
    /**\n
     * @param A: An integer array.\n
     * @param B: An integer array.\n
     * @return: a double whose format is *.5 or *.0\n
     */\n
\t    public double findMedianSortedArrays(int[] A, int[] B) {\n
\t\t        // write your code here\n
\t\t        int len = A.length + B.length;\n
\t\t        if (len % 2 == 0) {\n
\t\t\t            return (findKth(A, 0, B, 0, len/2) + findKth(A, 0, B, 0, len/2+1)) / 2.0;\n
\t\t        } else {\n\t
\t\t\t            return findKth(A, 0, B, 0, len/2 + 1);\n
\t\t        }\n
\t    }\n
\n
\t    //find kth number of two sorted array\n
\t    public static int findKth(int[] A, int A_start, int[] B, int B_start, int k) {\n
\t\t        if (A_start >= A.length) {\n
\t\t\t            return B[B_start + k - 1];\n
\t\t        }\n
\t\t        if (B_start >= B.length) {\n
\t\t\t            return A[A_start + k - 1];\n
\t\t        }\n
\t\t        if (k == 1) {\n
\t\t\t            return Math.min(A[A_start], B[B_start]);\n
\t\t        }\n
\n
\t\t        int A_key = (A_start + k/2 - 1 &lt; A.length) // if one array is too short
                    ? A[A_start + k/2 - 1] : Integer.MAX_VALUE; // trick\n
\t\t        int B_key = (B_start + k/2 - 1 &lt; B.length) // if one array is too short
                    ? B[B_start + k/2 - 1] : Integer.MAX_VALUE; // trick\n
\n
\t\t        if (A_key &lt; B_key) {\n
\t\t\t            return findKth(A, A_start + k/2, B, B_start, k - k/2);\n
\t\t        } else {\n
\t\t\t            return findKth(A, A_start, B, B_start + k/2, k - k/2);\n
\t\t        }\n
\t    }\n
}
</item>
</string-array>
<string-array name="sqrt_x_">
<item name="definition">
Implement int sqrt(int x).
\n
Compute and return the square root of x.
</item>
<item name="code">
public class Solution {\n
\t    public int sqrt(int x) {\n
\t\t        long i = 0;\n
\t\t        long j = x / 2 + 1;\n
\t\t        while (i &lt;= j) {\n
\t\t\t            long mid = (i + j) / 2;\n
\t\t\t            if (mid * mid == x)\n
\t\t\t\t                return (int)mid;\n
\t\t\t            if (mid * mid &lt; x)\n
\t\t\t\t                i = mid + 1;\n
\t\t\t            else\n
\t\t\t\t                j = mid - 1;\n
\t\t        }\n
\t\t        return (int)j;\n
\t    }\n
}
</item>
</string-array>
<string-array name="wood_cut_">
<item name="definition">
Given n pieces of wood with length L[i] (integer array).
Cut them into small pieces to guarantee you could have equal or more than k pieces with the same length.
What is the longest length you can get from the n pieces of wood?
Given L &amp; k, return the maximum length of the small pieces.
\n
Example\n
For L=[232, 124, 456], k=7, return 114.
\n
Note\n
You couldn\'t cut wood into float length.
\n
Challenge\n
O(n log Len), where Len is the longest length of the wood.
</item>
<item name="code">
public class Solution {\n
    /**\n
     *@param L: Given n pieces of wood with length L[i]\n
     *@param k: An integer\n
     *return: The maximum length of the small pieces.\n
     */\n
\t    public int woodCut(int[] L, int k) {\n
\t\t        int max = 0;\n
\t\t        for (int i = 0; i &lt; L.length; i++) {\n
\t\t\t            max = Math.max(max, L[i]);\n
\t\t        }\n
\n
\t\t        // find the largest length that can cut more than k pieces of wood.\n
\t\t        int start = 1, end = max;\n
\t\t        while (start + 1 &lt; end) {\n
\t\t\t            int mid = start + (end - start) / 2;\n
\t\t\t            if (count(L, mid) &gt;= k) {\n
\t\t\t\t                start = mid;\n
\t\t\t            } else {\n
\t\t\t\t                end = mid;\n
\t\t\t            }\n
\t\t        }\n
\n
\t\t        if (count(L, end) &gt;= k) {\n
\t\t\t            return end;\n
\t\t        }\n
 \t\t       if (count(L, start) &gt;= k) {\n
 \t\t\t           return start;\n
\t\t        }\n
\t\t        return 0;\n
\t    }\n
\n
\t    private int count(int[] L, int length) {\n
\t\t        int sum = 0;\n
\t\t        for (int i = 0; i &lt; L.length; i++) {\n
\t\t\t            sum += L[i] / length;\n
\t\t        }\n
\t\t        return sum;\n
\t    }\n
}
</item>
</string-array>

<string-array name="single_number_">
<item name="definition">
Given an array of integers, every element appears twice except for one. Find that single one.
\n
Note:\n
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
</item>
<item name="code">
    public int singleNumber(int[] A) {\n
\t	HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();\n
\t	for (int n : A) {\n
\t\t		if (!set.add(n))\n
\t\t\t			set.remove(n);\n
\t	}\n
\t	Iterator&lt;Integer&gt; it = set.iterator();\n
\t	return it.next();\n
}
</item>
</string-array>
<string-array name="single_number_ii_">
<item name="definition">
Given an array of integers, every element appears three times except for one. Find that single one.
\n
Note:\n
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
</item>
<item name="code">
    int singleNumber(int A[], int n) {\n
\t          vector&lt;int&gt; bit(32,0);\n
\n
\t          for(int i =0; i&lt; n; ++i)\n
\t          {\n
\t\t              int k=1;\n
\t\t              for(int j =0; j&lt;32; ++j)\n
\t\t              {\n
\t\t\t                 int rotated;\n
\t\t\t                 if((rotated = A[i]&gt;&gt;j) == 0) break;\n
\t\t\t                 bit[j] += rotated &amp; k;\n
\t\t             }\n
\t         }\n
\n
\t         int target=0;\n
\t         for(int i =0; i&lt;32; ++i)\n
\t         {\n
\t\t             target += (bit[i]%3 &lt;&lt;i);\n
\t         }\n
\t         return target;\n
     }
</item>
</string-array>

<string-array name="o_1_check_power_of_2_">
<item name="definition">
Using O(1) time to check whether an integer n is a power of 2.
\n
Example\n
For n=4, return true;
\n
For n=5, return false;
\n
Challenge
O(1) time
</item>
<item name="code">
    class Solution {\n
    /*\n
     * @param n: An integer\n
     * @return: True or false\n
     */\n
\t    public boolean checkPowerOf2(int n) {\n
\t\t        if (n &lt; 1) {\n
\t\t\t            return false;\n
\t\t        } else {\n
\t\t\t            return (n &amp; (n - 1)) == 0;\n
\t\t        }\n
\t    }\n
};
</item>
</string-array>
<string-array name="convert_integer_a_to_integer_b_">
<item name="definition">
Determine the number of bits required to convert integer A to integer B
\n
Example\n
Given n = 31, m = 14,return 2
\n
(31)10=(11111)2
\n
(14)10=(01110)2
</item>
<item name="code">
    class Solution {\n
    /**\n
     *@param a, b: Two integer\n
     *return: An integer\n
     */\n
\t    public static int bitSwapRequired(int a, int b) {\n
\t\t        int count = 0;\n
\t\t        int a_xor_b = a ^ b;\n
\t\t        while (a_xor_b != 0) {\n
\t\t\t            ++count;\n
\t\t\t            a_xor_b &amp;= (a_xor_b - 1);\n
\t\t        }\n
\t\t        return count;\n
\t    }\n
};\n
</item>
</string-array>
<string-array name="factorial_trailing_zeroes_">
<item name="definition">
Write an algorithm which computes the number of trailing zeros in n factorial.
\n
Example\n
11! = 39916800, so the out should be 2
\n
Challenge\n
O(log N) time
</item>
<item name="code">
    public class Solution {\n
\t    public int trailingZeroes(int n) {\n
\t\t        if (n &lt;0) {\n
\t\t\t            return -1;\n
\t\t        }\n
\t\t        int count = 0;\n
\t\t        for (; n &gt; 0; n /= 5) {\n
\t\t\t            count += (n / 5);\n
\t\t        }\n
\t\t        return count;\n
\t    }\n
}\n
</item>
</string-array>

<string-array name="remove_duplicates_from_sorted_list_">
<item name="definition">
Given a sorted linked list, delete all duplicates such that each element appear only once.
\n
Example\n
Given 1->1->2, return 1->2.\n
Given 1->1->2->3->3, return 1->2->3.
</item>
<item name="code">
    /**\n
 * http://www.jiuzhang.com/solutions/remove-duplicates-from-sorted-list/\n
 */\n

public class Solution {\n
\t    public ListNode deleteDuplicates(ListNode head) {\n
\t\t        if (head == null) {\n
\t\t\t            return null;\n
\t\t        }\n
\t\t        ListNode node = head;\n
\t\t        while (node.next != null) {\n
\t\t\t            if (node.val == node.next.val) {\n
\t\t\t\t                node.next = node.next.next;\n
\t\t\t            } else {\n
\t\t\t\t                node = node.next;\n
\t\t\t            }\n
\t\t        }\n
\t\t        return head;\n
\t    }\n
}\n
</item>
</string-array>
<string-array name="remove_duplicates_from_sorted_list_ii_">
<item name="definition">
Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.
\n
Example\n
Given 1->2->3->3->4->4->5, return 1->2->5.\n
Given 1->1->1->2->3, return 2->3.
</item>
<item name="code">
public ListNode deleteDuplicates(ListNode head) {\n
\t    ListNode t = new ListNode(0);\n
\t    t.next = head;\n
\t    ListNode p = t;\n
\t    while(p.next!=null&amp;&amp;p.next.next!=null){\n
\t\t        if(p.next.val == p.next.next.val){\n
\t\t\t            int dup = p.next.val;\n
\t\t\t            while(p.next!=null&amp;&amp;p.next.val==dup){\n
\t\t\t\t                p.next = p.next.next;\n
\t\t\t            }\n
\t\t        }else{\n
\t\t\t            p=p.next;\n
\t\t        }\n
\t    }\n
\t    return t.next;\n
}
</item>
</string-array>
<string-array name="partition_list_">
<item name="definition">
Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.
\n
You should preserve the original relative order of the nodes in each of the two partitions.
\n
For example,\n
Given 1->4->3->2->5->2->null and x = 3,\n
return 1->2->2->4->3->5->null.
</item>
<item name="code">
    public class Solution {\n
\t    public ListNode partition(ListNode head, int x) {\n
\t\t        if(head == null) return null;\n
\n
\t\t        ListNode fakeHead1 = new ListNode(0);\n
\t\t        ListNode fakeHead2 = new ListNode(0);\n
\t\t        fakeHead1.next = head;\n
\n
\t\t        ListNode p = head;\n
\t\t        ListNode prev = fakeHead1;\n
\t\t        ListNode p2 = fakeHead2;\n
\n
\t\t        while(p != null){\n
\t\t\t            if(p.val &lt; x){\n
\t\t\t\t                p = p.next;\n
\t\t\t\t                prev = prev.next;\n
\t\t\t            }else{\n
\t\t\t\t                p2.next = p;\n
\t\t\t\t                prev.next = p.next;\n
\t\t\t\t                p = prev.next;\n
\t\t\t\t                p2 = p2.next;\n
\t\t\t            }\n
\t\t        }\n
\t\t        // close the list\n
\t\t        p2.next = null;\n
\t\t        prev.next = fakeHead2.next;\n
\t\t        return fakeHead1.next;\n
\t    }\n
}
</item>
</string-array>
<string-array name="two_lists_sum_">
<item name="definition">
You have two numbers represented by a linked list, where each node contains a single digit.
The digits are stored in reverse order, such that the 1’s digit is at the head of the list.
Write a function that adds the two numbers and returns the sum as a linked list.
\n
Example\n
Given two lists, 3->1->5->null and 5->9->2->null, return 8->0->8->null
</item>
<item name="code">
    public class Solution {\n
\t    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n
\t\t       int carry =0;\n
\t\t        ListNode newHead = new ListNode(0);\n
\t\t        ListNode p1 = l1, p2 = l2, p3=newHead;\n
\t\t        while(p1 != null || p2 != null){\n
\t\t\t            if(p1 != null){\n
\t\t\t\t                carry += p1.val;\n
\t\t\t                p1 = p1.next;\n
\t\t            }\n
\t\t            if(p2 != null){\n
\t\t\t                carry += p2.val;\n
\t\t\t                p2 = p2.next;\n
\t\t            }\n
\t\t            p3.next = new ListNode(carry%10);\n
\t\t            p3 = p3.next;\n
\t\t            carry /= 10;\n
\t        }\n
\t        if(carry==1)\n
\t\t            p3.next=new ListNode(1);\n
\t\t        return newHead.next;\n
\t    }\n
}
</item>
</string-array>
<string-array name="two_lists_sum_advanced_">
<item name="definition">
Given two numbers represented by two linked lists, write a function that returns sum list.
The sum list is linked list representation of addition of two input numbers.
\n
Example
\n
Input:\n
  First  List: 5->6->3  // represents number 563\n
  Second List: 8->4->2  // represents number 842\n
Output\n
  Resultant list: 1->4->0->5  // represents number 1405
\n
Challenge
\n
Not allowed to modify the lists.
Not allowed to use explicit extra space.
</item>
<item name="code">
    // Java program to delete a given node in linked list under given constraints
\n
class LinkedList {\n
\n
    static Node head1, head2;
\n
    static class Node {
\n
        int data;\n
        Node next;\n
\n
        Node(int d) {\n
            data = d;\n
            next = null;\n
        }\n
    }\n
\n
    /* Adds contents of two linked lists and return the head node of resultant list */\n
    Node addTwoLists(Node first, Node second) {\n
        Node res = null; // res is head node of the resultant list\n
        Node prev = null;\n
        Node temp = null;\n
        int carry = 0, sum;\n
\n
        while (first != null || second != null) //while both lists exist{\n
            // Calculate value of next digit in resultant list.\n
            // The next digit is sum of following things\n
            // (i)  Carry\n
            // (ii) Next digit of first list (if there is a next digit)\n
            // (ii) Next digit of second list (if there is a next digit)\n
            sum = carry + (first != null ? first.data : 0)\n
                    + (second != null ? second.data : 0);\n
\n
            // update carry for next calulation\n
            carry = (sum >= 10) ? 1 : 0;\n
\n
            // update sum if it is greater than 10\n
            sum = sum % 10;\n
\n
            // Create a new node with sum as data\n
            temp = new Node(sum);\n
\n
            // if this is the first node then set it as head of\n
            // the resultant list\n
            if (res == null) {\n
                res = temp;\n
            } else // If this is not the first node then connect it to the rest.{\n
                prev.next = temp;\n
            }\n
\n
            // Set prev for next insertion\n
            prev = temp;\n
\n
            // Move first and second pointers to next nodes\n
            if (first != null) {\n
                first = first.next;\n
            }\n
            if (second != null) {\n
                second = second.next;\n
            }\n
        }\n
\n
        if (carry > 0) {\n
            temp.next = new Node(carry);\n
        }\n
\n
        // return head of the resultant list\n
        return res;\n
    }\n
    /* Utility function to print a linked list */\n
\n
    void printList(Node head) {\n
        while (head != null) {\n
            System.out.print(head.data + " ");\n
            head = head.next;\n
        }\n
        System.out.println("");\n
    }\n
\n
    public static void main(String[] args) {\n
        LinkedList list = new LinkedList();\n
\n
        // creating first list\n
        list.head1 = new Node(7);\n
        list.head1.next = new Node(5);\n
        list.head1.next.next = new Node(9);\n
        list.head1.next.next.next = new Node(4);\n
        list.head1.next.next.next.next = new Node(6);\n
        System.out.print("First List is ");\n
        list.printList(head1);\n
\n
        // creating seconnd list\n
        list.head2 = new Node(8);\n
        list.head2.next = new Node(4);\n
        System.out.print("Second List is ");\n
        list.printList(head2);\n
\n
        // add the two lists and see the result\n
        Node rs = list.addTwoLists(head1, head2);\n
        System.out.print("Resultant List is ");\n
        list.printList(rs);\n
    }\n
}
</item>
</string-array>
<string-array name="remove_nth_node_from_end_of_list_">
<item name="definition">
Given a linked list, remove the nth node from the end of list and return its head.
\n
Note\n
The minimum number of nodes in list is n.
\n
Example\n
Given linked list: 1->2->3->4->5->null, and n = 2.
\n
After removing the second node from the end, the linked list becomes 1->2->3->5->null.
\n
Challenge\n
O(n) time
</item>
<item name="code">
public ListNode removeNthFromEnd(ListNode head, int n) {\n
\t    if(head == null)\n
\t\t        return null;\n
\n
\t\t    //get length of list\n
\t\t    ListNode p = head;\n
\t\t    int len = 0;\n
\t\t    while(p != null){\n
\t\t\t        len++;\n
\t\t\t        p = p.next;\n
\t\t    }\n
\n
\t\t    //if remove first node\n
\t\t    int fromStart = len-n+1;\n
\t\t    if(fromStart==1)\n
\t\t\t        return head.next;\n
\n
\t\t    //remove non-first node\n
\t\t    p = head;\n
\t\t    int i=0;\n
\t\t    while(p!=null){\n
\t\t\t        i++;\n
\t\t\t        if(i==fromStart-1){\n
\t\t\t            p.next = p.next.next;\n
\t\t        }\n
\t\t        p=p.next;\n
\t    }\n
\n
\t    return head;\n
}
</item>
</string-array>
<string-array name="linked_list_cycle_">
<item name="definition">
Given a linked list, determine if it has a cycle in it.
\n
Example\n
Given -21->10->4->5, tail connects to node index 1, return true
\n
Challenge\n
Follow up:\n
Can you solve it without using extra space?
</item>
<item name="code">
    public class Solution {\n
\t    public Boolean hasCycle(ListNode head) {\n
\t\t        if (head == null || head.next == null) {\n
\t\t\t            return false;\n
\t\t        }\n
\n
\t\t        ListNode fast, slow;\n
\t\t        fast = head.next;\n
\t\t        slow = head;\n
\t\t        while (fast != slow) {\n
\t\t\t            if(fast==null || fast.next==null)\n
\t\t\t\t                return false;\n
\t\t\t            fast = fast.next.next;\n
\t\t\t            slow = slow.next;\n
\t\t        }\n
\t\t        return true;\n
\t    }\n
}
</item>
</string-array>
<string-array name="linked_list_cycle_ii_">
<item name="definition">
Given a linked list, return the node where the cycle begins. If there is no cycle, return null.
\n
Example\n
Given -21->10->4->5, tail connects to node index 1，return node 10
\n
Challenge\n
Follow up:\n
Can you solve it without using extra space?
</item>
<item name="code">
public class Solution {\n
\t    public ListNode detectCycle(ListNode head) {\n
\t\t        if (head == null || head.next==null) {\n
\t\t\t            return null;\n
\t\t        }\n
\n
\t\t        ListNode fast, slow;\n
\t\t        fast = head.next;\n
\t\t        slow = head;\n
\t\t        while (fast != slow) {\n
\t\t\t            if(fast==null || fast.next==null)\n
\t\t\t\t                return null;\n
\t\t\t            fast = fast.next.next;\n
\t\t\t            slow = slow.next;\n
\t\t        }\n
\n
\t\t        while (head != slow.next) {\n
\t\t\t            head = head.next;\n
\t\t\t            slow = slow.next;\n
\t\t        }\n
\t\t        return head;\n
\t    }\n
}
</item>
</string-array>
<string-array name="reverse_linked_list_">
<item name="definition">
Reverse a linked list.
\n
Example\n
For linked list 1->2->3, the reversed linked list is 3->2->1
\n
Challenge\n
Reverse it in-place and in one-pass
</item>
<item name="code">
    /**\n
 * Definition for ListNode.\n
 * public class ListNode {\n
 *     int val;\n
 *     ListNode next;\n
 *     ListNode(int val) {\n
 *         this.val = val;\n
 *         this.next = null;\n
 *     }\n
 * }\n
 */\n
public class Solution {\n
\t    /**\n
\t     * @param head: The head of linked list.\n
\t     * @return: The new head of reversed linked list.\n
\t     */\n
\t    public ListNode reverse(ListNode head) {\n
\t\t        ListNode prev = null;\n
\t\t        while (head != null) {\n
\t\t\t            ListNode temp = head.next;\n
\t\t\t            head.next = prev;\n
\t\t\t            prev = head;\n
\t\t\t            head = temp;\n
\t\t        }\n
\t\t        return prev;\n
\t    }\n
}
</item>
</string-array>
<string-array name="reverse_linked_list_ii_">
<item name="definition">
Reverse a linked list from position m to n.
\n
Note\n
Given m, n satisfy the following condition: 1 ≤ m ≤ n ≤ length of list.
\n
Example\n
Given 1->2->3->4->5->NULL, m = 2 and n = 4, return 1->4->3->2->5->NULL.
\n
Challenge\n
Reverse it in-place and in one-pass
</item>
<item name="code">
/**\n
 * Definition for ListNode\n
 * public class ListNode {\n
 *     int val;\n
 *     ListNode next;\n
 * }\n
 */\n
public class Solution {\n
\t    public ListNode reverseBetween(ListNode head, int m, int n) {\n
\t\t        if (m >= n || head == null) {\n
\t\t\t            return head;\n
\t\t        }\n
\n
\t\t        ListNode dummy = new ListNode(0);\n
\t\t        dummy.next = head;\n
\t\t        head = dummy;\n
\n
\t\t        for (int i = 1; i &lt; m; i++) {\n
\t\t\t            if (head == null) {\n
\t\t\t\t                return null;\n
\t\t\t            }\n
\t\t\t            head = head.next;\n
\t\t        }\n
\n
\t\t        ListNode premNode = head;\n
\t\t        ListNode mNode = head.next;\n
\t\t        ListNode nNode = mNode, postnNode = mNode.next;\n
\t\t        for (int i = m; i &lt; n; i++) {\n
\t\t\t            if (postnNode == null) {\n
\t\t\t\t                return null;\n
\t\t\t            }\n
\t\t\t            ListNode temp = postnNode.next;\n
\t\t\t            postnNode.next = nNode;\n
\t\t\t            nNode = postnNode;\n
\t\t\t            postnNode = temp;\n
\t\t        }\n
\t\t        mNode.next = postnNode;\n
\t\t        premNode.next = nNode;\n
\n
\t\t        return dummy.next;\n
\t    }\n
}
</item>
</string-array>
<string-array name="merge_two_sorted_lists_">
<item name="definition">
Merge two sorted linked lists and return it as a new list.
The new list should be made by splicing together the nodes of the first two lists.
\n
Example\n
Given 1->3->8->11->15->null, 2->null , return 1->2->3->8->11->15->null
</item>
<item name="code">
public class Solution {\n
\t    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n
\t\t        ListNode dummy = new ListNode(0);\n
\t\t        ListNode lastNode = dummy;\n
\n
\t\t        while (l1 != null &amp;&amp; l2 != null) {\n
\t\t\t            if (l1.val &lt; l2.val) {\n
\t\t\t\t                lastNode.next = l1;\n
\t\t\t\t                l1 = l1.next;\n
\t\t\t            } else {\n
\t\t\t\t                lastNode.next = l2;\n
\t\t\t\t                l2 = l2.next;\n
\t\t\t            }\n
\t\t\t            lastNode = lastNode.next;\n
\t\t        }\n
\n
\t\t        if (l1 != null) {\n
\t\t\t            lastNode.next = l1;\n
\t\t        } else {\n
\t\t\t            lastNode.next = l2;\n
\t\t        }\n
\n
\t\t        return dummy.next;\n
\t    }\n
}
</item>
</string-array>
<string-array name="merge_k_sorted_lists_">
<item name="definition">
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
</item>
<item name="code">
    /**\n
 * Definition for ListNode.\n
 *\t public class ListNode {\n
 *\t\t     int val;\n
 * \t\t    ListNode next;\n
 * \t\t    ListNode(int val) {\n
    *\t\t\t         this.val = val;\n
 * \t\t\t        this.next = null;\n
 * \t\t    }\n
 *\t }\n
 */\n
public class Solution {\n
\t    /**\n
\t     * @param lists: a list of ListNode\n
\t     * @return: The head of one sorted list.\n
\t     */\n
\t    public ListNode mergeKLists(List&lt;ListNode&gt; lists) {\n
\t\t        if (lists.size() == 0) {\n
\t\t\t            return null;\n
\t\t        }\n
\t\t        return mergeHelper(lists, 0, lists.size() - 1);\n
\t    }\n
\n
\t    private ListNode mergeHelper(List&lt;ListNode&gt; lists, int start, int end) {\n
\t\t        if (start == end) {\n
\t\t\t            return lists.get(start);\n
\t\t        }\n
\n
\t\t        int mid = start + (end - start) / 2;\n
\t\t        ListNode left = mergeHelper(lists, start, mid);\n
\t\t        ListNode right = mergeHelper(lists, mid + 1, end);\n
\t\t        return mergeTwoLists(left, right);\n
\t    }\n
\n
\t    private ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n
\t\t        ListNode dummy = new ListNode(0);\n
\t\t        ListNode tail = dummy;\n
\t\t        while (list1 != null &amp;&amp; list2 != null) {\n
\t\t\t            if (list1.val &lt; list2.val) {\n
\t\t\t\t                tail.next = list1;\n
\t\t\t\t                tail = list1;\n
\t\t\t\t                list1 = list1.next;\n
\t\t\t            } else {\n
\t\t\t\t                tail.next = list2;\n
\t\t\t\t                tail = list2;\n
\t\t\t\t                list2 = list2.next;\n
\t\t\t            }\n
\t\t        }\n
\t\t        if (list1 != null) {\n
\t\t\t            tail.next = list1;\n
\t\t        } else {\n
    \t\t\t tail.next = list2;\n
\t\t        }\n
\n
\t\t        return dummy.next;\n
\t    }\n
}
</item>
</string-array>
<string-array name="sort_list_">
<item name="definition">
Sort a linked list in O(n log n) time using constant space complexity.
</item>
<item name="code">
// version 1: Merge Sort\n
public class Solution {\n
\t    private ListNode findMiddle(ListNode head) {\n
\t\t        ListNode slow = head, fast = head.next;\n
\t\t        while (fast != null &amp;&amp; fast.next != null) {\n
\t\t\t            fast = fast.next.next;\n
\t\t\t            slow = slow.next;\n
\t\t        }\n
\t\t        return slow;\n
\t    }\n
\n
\t    private ListNode merge(ListNode head1, ListNode head2) {\n
\t\t        ListNode dummy = new ListNode(0);\n
\t\t        ListNode tail = dummy;\n
\t\t        while (head1 != null &amp;&amp; head2 != null) {\n
\t\t\t            if (head1.val &lt; head2.val) {\n
\t\t\t\t                tail.next = head1;\n
\t\t\t\t                head1 = head1.next;\n
\t\t\t            } else {\n
\t\t\t\t                tail.next = head2;\n
\t\t\t\t                head2 = head2.next;\n
\t\t\t            }\n
\t\t\t\t            tail = tail.next;\n
\t\t\t        }\n
\t\t        if (head1 != null) {\n
\t\t\t            tail.next = head1;\n
\t\t        } else {\n
\t\t\t            tail.next = head2;\n
\t\t        }\n

\t\t        return dummy.next;\n
\t    }\n
\n
\t    public ListNode sortList(ListNode head) {\n
\t\t        if (head == null || head.next == null) {\n
\t\t\t            return head;\n
\t\t        }\n
\n
\t\t        ListNode mid = findMiddle(head);\n
\t\t        ListNode right = sortList(mid.next);\n
\t\t        mid.next = null;\n
\t\t        ListNode left = sortList(head);\n
\n
\t\t        return merge(left, right);\n
\t    }\n
}
</item>
</string-array>
<string-array name="recorder_list_">
<item name="definition">
Given a singly linked list L: L0→L1→…→Ln-1→Ln, reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You must do this in-place without altering the nodes\' values. For example, Given {1,2,3,4}, reorder it to {1,4,2,3}.
</item>
<item name="code">
public class Solution {\n
\t    private ListNode reverse(ListNode head) {\n
\t\t        ListNode newHead = null;\n
\t\t        while (head != null) {\n
\t\t\t            ListNode temp = head.next;\n
\t\t\t            head.next = newHead;\n
\t\t\t            newHead = head;\n
\t\t\t            head = temp;\n
\t\t        }\n
\t\t        return newHead;\n
\t    }\n
\n
\t    private void merge(ListNode head1, ListNode head2) {\n
\t\t        int index = 0;\n
\t\t        ListNode dummy = new ListNode(0);\n
\t\t        while (head1 != null &amp;&amp; head2 != null) {\n
\t\t\t            if (index % 2 == 0) {\n
\t\t\t\t                dummy.next = head1;\n
\t\t\t\t                head1 = head1.next;\n
\t\t\t            } else {\n
\t\t\t\t                dummy.next = head2;\n
\t\t\t\t                head2 = head2.next;\n
\t\t\t            }\n
\t\t\t            dummy = dummy.next;\n
\t\t\t            index ++;\n
\t\t        }\n
\t\t        if (head1 != null) {\n
\t\t\t            dummy.next = head1;\n
\t\t        } else {\n
\t\t\t            dummy.next = head2;\n
\t\t        }\n
\t    }\n
\n
\t    private ListNode findMiddle(ListNode head) {\n
\t\t        ListNode slow = head, fast = head.next;\n
\t\t        while (fast != null &amp;&amp; fast.next != null) {\n
\t\t\t            fast = fast.next.next;\n
\t\t\t            slow = slow.next;\n
\t\t        }\n
\t\t        return slow;\n
\t    }\n
\n
\t    public void reorderList(ListNode head) {\n
\t\t        if (head == null || head.next == null) {\n
\t\t\t            return;\n
\t\t        }\n
\n
\t\t        ListNode mid = findMiddle(head);\n
\t\t        ListNode tail = reverse(mid.next);\n
\t\t        mid.next = null;\n
\n
\t\t        merge(head, tail);\n
\t    }\n
}
</item>
</string-array>

<string-array name="recover_rotated_sorted_array_">
<item name="definition">
Given a rotated sorted array, recover it to sorted array in-place.
\n
Example\n
[4, 5, 1, 2, 3] -> [1, 2, 3, 4, 5]
\n
Challenge\n
In-place, O(1) extra space and O(n) time.
\n
Clarification\n
What is rotated array:
\n
    - For example, the orginal array is [1,2,3,4], The rotated array of it can be [1,2,3,4], [2,3,4,1], [3,4,1,2], [4,1,2,3]
</item>
<item name="code">
    public class Solution {\n
 \t   /**\n
 \t    * @param nums: The rotated sorted array\n
 \t    * @return: The recovered sorted array\n
 \t    */\n
 \t   public void recoverRotatedSortedArray(ArrayList nums) {\n
 \t\t       if (nums == null || nums.size() &lt;= 1) {\n
 \t\t\t           return;\n
 \t\t       }\n
\n
 \t\t       int pos = 1;\n
 \t\t       while (pos &lt; nums.size()) { // find the break point\n
 \t\t\t           if (nums.get(pos - 1) > nums.get(pos)) {\n
 \t\t\t\t              break;\n
 \t\t\t           }\n
 \t\t\t           pos++;\n
  \t\t      }\n
  \t\t      myRotate(nums, 0, pos - 1);\n
  \t\t      myRotate(nums, pos, nums.size() - 1);\n
  \t\t      myRotate(nums, 0, nums.size() - 1);\n
  \t  }\n
\n
 \t   private void myRotate(ArrayList nums, int left, int right) { // in-place rotate\n
 \t\t       while (left &lt; right) {\n
 \t\t\t           int temp = nums.get(left);\n
 \t\t\t           nums.set(left, nums.get(right));\n
 \t\t\t           nums.set(right, temp);\n
 \t\t\t           left++;\n
 \t\t\t           right--;\n
 \t\t       }\n
 \t   }\n
}
</item>
</string-array>
<string-array name="rotate_string_">
<item name="definition">
Given a string and an offset, rotate string by offset. (rotate from left to right)
\n
Example\n
Given "abcdefg"
\n
for offset=0, return "abcdefg"\n

for offset=1, return "gabcdef"
\n
for offset=2, return "fgabcde"
\n
for offset=3, return "efgabcd"
\n
...
</item>
<item name="code">
public class Solution {\n
\t    public String reverseWords(String s) {\n
\t\t        if (s == null || s.length() == 0) {\n
\t\t\t            return "";\n
\t\t        }\n
\n
\t\t        String[] array = s.split(" ");\n
\t\t        StringBuilder sb = new StringBuilder();\n
\n
\t\t        for (int i = array.length - 1; i >= 0; --i) {\n
\t\t\t            if (!array[i].equals("")) {\n
\t\t\t\t                sb.append(array[i]).append(" ");\n
\t\t\t            }\n
\t\t        }\n
\n
\t\t        //remove the last " "\n
\t\t        return sb.length() == 0 ? "" : sb.substring(0, sb.length() - 1);\n
\t    }\n
}
</item>
</string-array>
<string-array name="reverse_words_in_a_string_">
<item name="definition">
Given an input string, reverse the string word by word.
\n
For example,\n
Given s = \"the sky is blue\",\n
return \"blue is sky the\".
\n
Example\n
Clarification\n
\n
 - What constitutes a word?\n
A sequence of non-space characters constitutes a word.
\n
 - Could the input string contain leading or trailing spaces?\n
Yes. However, your reversed string should not contain leading or trailing spaces.
\n
 - How about multiple spaces between two words?\n
Reduce them to a single space in the reversed string.
</item>
<item name="code">
    public void rotate(int[] nums, int k) {\n
\t    if(k > nums.length)\n
\t        k=k%nums.length;\n
\n
\t    int[] result = new int[nums.length];\n
\n
\t    for(int i=0; i &lt; k; i++){\n
\t\t        result[i] = nums[nums.length-k+i];\n
\t    }\n
\n
\t    int j=0;\n
\t    for(int i=k; i&lt;nums.length; i++){\n
\t\t        result[i] = nums[j];\n
\t\t        j++;\n
\t    }\n
\t    System.arraycopy( result, 0, nums, 0, nums.length );\n
}
</item>
</string-array>
<string-array name="binary_tree_preorder_traversal_">
<item name="definition">
Given a binary tree, return the preorder traversal of its nodes\' values.
\n
For example:\n
Given binary tree {1,#,2,3},
\n
 1  \n
\t   \'  \n
     2  \n
    /  \n
  3  \n
return [1,2,3].
\n
 Note: Recursive solution is trivial, could you do it iteratively?
</item>
<item name="code">
    public class Solution {\n
\t    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {\n
\t\t        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();\n
\t\t        List&lt;Integer&gt; preorder = new ArrayList&lt;Integer&gt;();\n
\n
\t\t        if (root == null) {\n
 \t\t           return preorder;\n
\t        }\n
\n
\t        stack.push(root);\n
\t        while (!stack.empty()) {\n
\t\t            TreeNode node = stack.pop();\n
\t\t            preorder.add(node.val);\n
\t\t            if (node.right != null) {\n
\t\t\t                stack.push(node.right);\n
\t\t            }\n
\t\t            if (node.left != null) {\n
\t\t\t                stack.push(node.left);\n
\t\t            }\n
\t\t        }\n
\n
\t        return preorder;\n
\t    }\n
}\n
\n
//Version 1: Traverse\n
public class Solution {\n
\t    public ArrayList&lt;Integer&gt; preorderTraversal(TreeNode root) {\n
\t\t        ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();\n
\t\t        traverse(root, result);\n
\t\t        return result;\n
\t    }\n
\n
\t    private void traverse(TreeNode root, ArrayList&lt;Integer&gt; result) {\n
\t\t        if (root == null) {\n
\t\t\t            return;\n
\t\t        }\n
\t\t        result.add(root.val);\n
\t\t        traverse(root.left, result);\n
\t\t        traverse(root.right, result);\n
\t    }\n
}\n
</item>
</string-array>
<string-array name="binary_tree_inorder_traversal_">
<item name="definition">
Given a binary tree, return the inorder traversal of its nodes\' values.
\n
Example\n
Given binary tree {1,#,2,3},
\n
   1  \n
    \  \n
     2  \n
    /  \n
   3  \n
\n
return [1,3,2].
\n
Challenge\n
Can you do it without recursion?
</item>
<item name="code">
    public class Solution {\n
    /**\n
     * @param root: The root of binary tree.\n
     * @return: Inorder in ArrayList which contains node values.\n
     */\n
    public ArrayList&lt;Integer&gt;inorderTraversal(TreeNode root) {\n
        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();\n
        ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();\n
        TreeNode curt = root;\n
        while (curt != null || !stack.empty()) {\n
            while (curt != null) {\n
                stack.add(curt);\n
                curt = curt.left;\n
            }\n
            curt = stack.peek();\n
            stack.pop();\n
            result.add(curt.val);\n
            curt = curt.right;\n
        }\n
        return result;\n
    }\n
}
</item>
</string-array>
<string-array name="binary_tree_postorder_traversal_">
<item name="definition">
Given a binary tree, return the postorder traversal of its nodes\' values.
For example:\n
Given binary tree {1,#,2,3},\n
1 \n
  \ \n
   2 \n
  / \n
 3 \n
return [3,2,1].\n
 Note: Recursive solution is trivial, could you do it iteratively?
</item>
<item name="code">
    //Recursive\n
public ArrayList&lt;Integer&gt; postorderTraversal(TreeNode root) {\n
    ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();\n
    if (root == null) {\n
        return result;\n
    }\n
    result.addAll(postorderTraversal(root.left));\n
    result.addAll(postorderTraversal(root.right));\n
    result.add(root.val);\n
    return result;\n
}\n
//Iterative\n
public ArrayList&lt;Integer&gt; postorderTraversal(TreeNode root) {\n
    ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();\n
    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();\n
    TreeNode prev = null; // previously traversed node\n
    TreeNode curr = root;\n
    if (root == null) {\n
        return result;\n
    }\n
    stack.push(root);\n
    while (!stack.empty()) {\n
        curr = stack.peek();\n
        if (prev == null || prev.left == curr || prev.right == curr) { // traverse down the tree\n
            if (curr.left != null) {\n
                stack.push(curr.left);\n
            } else if (curr.right != null) {\n
                stack.push(curr.right);\n
            }\n
        } else if (curr.left == prev) { // traverse up the tree from the left\n
            if (curr.right != null) {\n
                stack.push(curr.right);\n
            }\n
        } else { // traverse up the tree from the right\n
            result.add(curr.val);\n
            stack.pop();\n
        }\n
        prev = curr;\n
    }\n
\n
    return result;\n
}
</item>
</string-array>
<string-array name="binary_tree_level_order_traversal_">
<item name="definition">
Given a binary tree, return the level order traversal of its nodes\' values. (ie, from left to right, level by level). For example: Given binary tree {3,9,20,#,#,15,7}, 3 / \ 9 20 / \ 15 7 return its level order traversal as: [ [3], [9,20], [15,7] ]
</item>
<item name="code">
    // version 1: BFS\n
public class Solution {\n
    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n
        ArrayList result = new ArrayList();\n
        if (root == null) {\n
            return result;\n
        }\n
\n
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();\n
        queue.offer(root);\n
\n
        while (!queue.isEmpty()) {\n
            ArrayList&lt;Integer&gt; level = new ArrayList&lt;Integer&gt;();\n
            int size = queue.size();\n
            for (int i = 0; i &lt; size; i++) {\n
                TreeNode head = queue.poll();\n
                level.add(head.val);\n
                if (head.left != null) {\n
                    queue.offer(head.left);\n
                }\n
                if (head.right != null) {\n
                    queue.offer(head.right);\n
                }\n
            }\n
            result.add(level);\n
        }\n
        return result;\n
    }\n
}
</item>
</string-array>
<string-array name="maximum_depth_of_binary_tree_">
<item name="definition">
Given a binary tree, find its maximum depth.\n
The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n
Example\n
Given a binary tree as follow:\n
        1 \n
     /     \ \n
   2       3 \n
          /    \ \n
        4      5 \n
The maximum depth is 3
</item>
<item name="code">
    public class Solution {\n
    public int maxDepth(TreeNode root) {\n
        if (root == null) {\n
            return 0;\n
        }\n
\n
        int left = maxDepth(root.left);\n
        int right = maxDepth(root.right);\n
        return Math.max(left, right) + 1;\n
    }\n
}\n
\n
// version 2: Traverse\n
\n
/**\n
 * Definition of TreeNode:\n
 * public class TreeNode {\n
 *     public int val;\n
 *     public TreeNode left, right;\n
 *     public TreeNode(int val) {\n
 *         this.val = val;\n
 *         this.left = this.right = null;\n
 *     }\n
 * }\n
 */\n
public class Solution {\n
    /**\n
     * @param root: The root of binary tree.\n
     * @return: An integer.\n
     */\n
    private int depth;\n
\n
    public int maxDepth(TreeNode root) {\n
        depth = 0;\n
        helper(root, 1);\n
        return depth;\n
    }\n
    private void helper(TreeNode node, int curtDepth) {\n
        if (node == null) {\n
            return;\n
        }\n
        if (curtDepth &gt; depth) {\n
            depth = curtDepth;\n
        }\n
        helper(node.left, curtDepth + 1);\n
        helper(node.right, curtDepth + 1);\n
    }\n
}
</item>
</string-array>
<string-array name="balanced_binary_tree_">
<item name="definition">
Given a binary tree, determine if it is height-balanced.
\n
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.
\n
Example
\n
Given binary tree A={3,9,20,#,#,15,7}, B={3,#,20,15,7}
\n
A)  3            B)    3 \n
   / \                  \ \n
  9  20                 20 \n
    /  \                / \ \n
   15   7              15  7 \n
\n
The binary tree A is a height-balanced binary tree, but B is not.
</item>
<item name="code">
    // Version 1: with ResultType\n
/**\n
 * Definition of TreeNode:\n
 * public class TreeNode {\n
 *     public int val;\n
 *     public TreeNode left, right;\n
 *     public TreeNode(int val) {\n
 *         this.val = val;\n
 *         this.left = this.right = null;\n
 *     }\n
 * }\n
 */\n
class ResultType {\n
    public boolean isBalanced;\n
    public int maxDepth;\n
    public ResultType(boolean isBalanced, int maxDepth) {\n
        this.isBalanced = isBalanced;\n
        this.maxDepth = maxDepth;\n
    }\n
}\n
\n
public class Solution {\n
    /**\n
     * @param root: The root of binary tree.\n
     * @return: True if this Binary tree is Balanced, or false.\n
     */\n
    public boolean isBalanced(TreeNode root) {\n
        return helper(root).isBalanced;\n
    }\n
\n
    private ResultType helper(TreeNode root) {\n
        if (root == null) {\n
            return new ResultType(true, 0);\n
        }\n
\n
        ResultType left = helper(root.left);\n
        ResultType right = helper(root.right);\n
\n
        // subtree not balance\n
        if (!left.isBalanced || !right.isBalanced) {\n
            return new ResultType(false, -1);\n
        }\n
\n
        // root not balance\n
        if (Math.abs(left.maxDepth - right.maxDepth) &gt; 1) {\n
            return new ResultType(false, -1);\n
        }\n
\n
        return new ResultType(true, Math.max(left.maxDepth, right.maxDepth) + 1);\n
    }\n
}\n
\n
// Version 2: without ResultType\n
public class Solution {\n
    public boolean isBalanced(TreeNode root) {\n
        return maxDepth(root) != -1;\n
    }\n
\n
    private int maxDepth(TreeNode root) {\n
        if (root == null) {\n
            return 0;\n
        }\n
\n
        int left = maxDepth(root.left);\n
        int right = maxDepth(root.right);\n
        if (left == -1 || right == -1 || Math.abs(left-right) > 1) {\n
            return -1;\n
        }\n
        return Math.max(left, right) + 1;\n
    }\n
}\n
</item>
</string-array>
<string-array name="binary_tree_maximum_path_sum_">
<item name="definition">
Given a binary tree, find the maximum path sum.
\n
The path may start and end at any node in the tree.
Example\n
Given the below binary tree,
\n
       1 \n
      / \ \n
     2   3 \n
Return 6. \n
</item>
<item name="code">
public class Solution {\n
    private class ResultType {\n
        // singlePath:\n
        // maxPath:\n
        int singlePath, maxPath;\n
        ResultType(int singlePath, int maxPath) {\n
            this.singlePath = singlePath;\n
            this.maxPath = maxPath;\n
        }\n
    }\n
\n
    private ResultType helper(TreeNode root) {\n
        if (root == null) {\n
            return new ResultType(0, Integer.MIN_VALUE);\n
        }\n
        // Divide\n
        ResultType left = helper(root.left);\n
        ResultType right = helper(root.right);\n
\n
        // Conquer\n
        int singlePath = Math.max(left.singlePath, right.singlePath) + root.val;\n
        singlePath = Math.max(singlePath, 0);\n
\n
        int maxPath = Math.max(left.maxPath, right.maxPath);\n
        maxPath = Math.max(maxPath, left.singlePath + right.singlePath + root.val);\n
\n
        return new ResultType(singlePath, maxPath);\n
    }\n
\n
    public int maxPathSum(TreeNode root) {\n
        ResultType result = helper(root);\n
        return result.maxPath;\n
    }\n
}
</item>
</string-array>
<string-array name="lowest_common_ancestor_">
<item name="definition">
Given the root and two nodes in a Binary Tree. Find the lowest common ancestor(LCA) of the two nodes.
The lowest common ancestor is the node with largest depth which is the ancestor of both nodes.
Example\n
        4 \n
    /     \ \n
  3         7 \n
          /     \ \n
        5         6 \n
For 3 and 5, the LCA is 4.\n
For 5 and 6, the LCA is 7.\n
For 6 and 7, the LCA is 7.\n
</item>
<item name="code">
Version 1: Traditional Method
\n
public class Solution {\n
    private ArrayList&lt;TreeNode&gt; getPath2Root(TreeNode node) {\n
        ArrayList&lt;TreeNode&gt; list = new ArrayList&lt;TreeNode&gt;();\n
        while (node != null) {\n
            list.add(node);\n
            node = node.parent;\n
        }\n
        return list;\n
    }\n
    public TreeNode lowestCommonAncestor(TreeNode node1, TreeNode node2) {\n
        ArrayList&lt;TreeNode&gt; list1 = getPath2Root(node1);\n
        ArrayList&lt;TreeNode&gt; list2 = getPath2Root(node2);\n
\n
        int i, j;\n
        for (i = list1.size() - 1, j = list2.size() - 1; i >= 0 &amp;&amp; j >= 0; i--, j--) {\n
            if (list1.get(i) != list2.get(j)) {\n
                return list1.get(i).parent;\n
            }\n
        }\n
        return list1.get(i+1);\n
    }\n
}\n
Version 2: Divide &amp; Conquer\n
public class Solution {\n
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode node1, TreeNode node2) {\n
        if (root == null || root == node1 || root == node2) {\n
            return root;\n
        }\n
        // Divide\n
        TreeNode left = lowestCommonAncestor(root.left, node1, node2);\n
        TreeNode right = lowestCommonAncestor(root.right, node1, node2);\n
        // Conquer\n
        if (left != null &amp;&amp; right != null) {\n
            return root;\n
        }\n
        if (left != null) {\n
            return left;\n
        }\n
        if (right != null) {\n
            return right;\n
        }\n
        return null;\n
    }\n
}
</item>
</string-array>

<string-array name="insert_node_in_a_binary_search_tree_">
<item name="definition">
Given a binary search tree  and a new tree node, insert the node into the tree. You should keep the tree still be a valid binary search tree.
\n
Example\n
Given binary search tree as follow:\n
     2 \n
  /    \ \n
1        4 \n
         / \n
       3 \n
after Insert node 6, the tree should be:\n
     2 \n
  /    \ \n
1        4 \n
         /   \ \n
       3        6 \n
Challenge\n
Do it without recursion
</item>
<item name="code">
    version 1:\n
\n
/**\n
 * Definition of TreeNode:\n
 * public class TreeNode {\n
 *     public int val;\n
 *     public TreeNode left, right;\n
 *     public TreeNode(int val) {\n
 *         this.val = val;\n
 *         this.left = this.right = null;\n
 *     }\n
 * }\n
 */\n
public class Solution {\n
    /**\n
     * @param root: The root of the binary search tree.\n
     * @param node: insert this node into the binary search tree\n
     * @return: The root of the new binary search tree.\n
     */\n
    public TreeNode insertNode(TreeNode root, TreeNode node) {\n
        if (root == null) {\n
            root = node;\n
            return root;\n
        }\n
        TreeNode tmp = root;\n
        TreeNode last = null;\n
        while (tmp != null) {\n
            last = tmp;\n
            if (tmp.val > node.val) {\n
                tmp = tmp.left;\n
            } else {\n
                tmp = tmp.right;\n
            }\n
        }\n
        if (last != null) {\n
            if (last.val > node.val) {\n
                last.left = node;\n
            } else {\n
                last.right = node;\n
            }\n
        }\n
        return root;\n
    }\n
}\n
version 2:\n
/**\n
 * Definition of TreeNode:\n
 * public class TreeNode {\n
 *     public int val;\n
 *     public TreeNode left, right;\n
 *     public TreeNode(int val) {\n
 *         this.val = val;\n
 *         this.left = this.right = null;\n
 *     }\n
 * }\n
 */\n
public class Solution {\n
    /**\n
     * @param root: The root of the binary search tree.\n
     * @param node: insert this node into the binary search tree\n
     * @return: The root of the new binary search tree.\n
     */\n
    public TreeNode insertNode(TreeNode root, TreeNode node) {\n
        if (root == null) {\n
            return node;\n
        }\n
        if (root.val > node.val) {\n
            root.left = insertNode(root.left, node);\n
        } else {\n
            root.right = insertNode(root.right, node);\n
        }\n
        return root;\n
    }\n
}
</item>
</string-array>
<string-array name="validate_binary_search_tree_">
<item name="definition">
Given a binary tree, determine if it is a valid binary search tree (BST).
\n
Assume a BST is defined as follows:
\n
The left subtree of a node contains only nodes with keys less than the node\'s key.\n
The right subtree of a node contains only nodes with keys greater than the node\'s key.\n
Both the left and right subtrees must also be binary search trees.\n
Example\n
An example:\n
\n
   1\n
  / \'\n
 2   3\n
    /\n
   4\n
    \'\n
     5\n
The above binary tree is serialized as \"{1,2,3,#,#,4,#,#,5}\".
</item>
<item name="code">
// version 1 Traverse\n
public class Solution {\n
    private int lastVal = Integer.MIN_VALUE;\n
    private boolean firstNode = true;\n
    public boolean isValidBST(TreeNode root) {\n
        if (root == null) {\n
            return true;\n
        }\n
        if (!isValidBST(root.left)) {\n
            return false;\n
        }\n
        if (!firstNode &amp;&amp; lastVal &gt;= root.val) {\n
            return false;\n
        }\n
        firstNode = false;\n
        lastVal = root.val;\n
        if (!isValidBST(root.right)) {\n
            return false;\n
        }\n
        return true;\n
    }\n
}\n
\n
// version 2  Divide and Conquer\n
class ResultType {\n
    boolean is_bst;\n
    int maxValue, minValue;\n
\n
    ResultType(boolean is_bst, int maxValue, int minValue) {\n
        this.is_bst = is_bst;\n
        this.maxValue = maxValue;\n
        this.minValue = minValue;\n
    }\n
}\n
\n
public class Solution {\n
    /**\n
     * @param root: The root of binary tree.\n
     * @return: True if the binary tree is BST, or false\n
     */\n
    public boolean isValidBST(TreeNode root) {\n
        ResultType r = validateHelper(root);\n
        return r.is_bst;\n
    }\n
\n
    private ResultType validateHelper(TreeNode root) {\n
        if (root == null) {\n
            return new ResultType(true, Integer.MIN_VALUE, Integer.MAX_VALUE);\n
        }\n
\n
        ResultType left = validateHelper(root.left);\n
        ResultType right = validateHelper(root.right);\n
\n
        if (!left.is_bst || !right.is_bst) {\n
            // if is_bst is false then minValue and maxValue are useless\n
            return new ResultType(false, 0, 0);\n
        }\n
\n
        if (root.left != null &amp;&amp; left.maxValue &gt;= root.val ||\n
              root.right != null &amp;&amp; right.minValue &lt;= root.val) {\n
            return new ResultType(false, 0, 0);\n
        }\n
\n
        return new ResultType(true,\n
                              Math.max(root.val, right.maxValue),\n
                              Math.min(root.val, left.minValue));\n
    }\n
}
</item>
</string-array>
<string-array name="search_range_in_binary_search_tree_">
<item name="definition">
Given two values k1 and k2 (where k1 &lt; k2) and a root pointer to a Binary Search Tree.
Find all the keys of tree in range k1 to k2. i.e. print all x such that k1&lt;=x&lt;=k2 and x is a key of given BST.
Return all the keys in ascending order.\n
Example\n
For example, if k1 = 10 and k2 = 22, then your function should print 12, 20 and 22.\n
          20 \n
       /      \' \n
    8           22 \n
  /    \' \n
4       12 \n
</item>
<item name="code">
/**\n
 * Definition of TreeNode:\n
 * public class TreeNode {\n
 *     public int val;\n
 *     public TreeNode left, right;\n
 *     public TreeNode(int val) {\n
 *         this.val = val;\n
 *         this.left = this.right = null;\n
 *     }\n
 * }\n
 */\n
public class Solution {\n
\t    private ArrayList&lt;Integer&gt; results;\n
    /**\n
     * @param root: The root of the binary search tree.\n
     * @param k1 and k2: range k1 to k2.\n
     * @return: Return all keys that k1&lt;=key&lt;=k2 in increasing order.\n
     */\n
\t    public ArrayList&lt;Integer&gt; searchRange(TreeNode root, int k1, int k2) {\n
\t\t        results = new ArrayList&lt;Integer&gt;();\n
\t\t        helper(root, k1, k2);\n
\t\t        return results;\n
\t    }\n
\n
\t    private void helper(TreeNode root, int k1, int k2) {\n
\t\t        if (root == null) {\n
\t\t\t            return;\n
\t\t        }\n
\t\t        if (root.val &gt; k1) {\n
\t\t\t            helper(root.left, k1, k2);\n
\t\t        }\n
\t\t        if (root.val &gt;= k1 &amp;&amp; root.val &lt;= k2) {\n
\t\t\t            results.add(root.val);\n
\t\t        }\n
\t\t        if (root.val &lt; k2) {\n
\t\t\t            helper(root.right, k1, k2);\n
\t\t        }\n
\t    }\n
}
</item>
</string-array>
<string-array name="convert_sorted_array_to_binary_search_tree_">
<item name="definition">
Given two values k1 and k2 (where k1 &lt; k2) and a root pointer to a Binary Search Tree.
Find all the keys of tree in range k1 to k2. i.e. print all x such that k1&lt;=x&lt;=k2 and x is a key of given BST.
Return all the keys in ascending order.\n
Example\n
For example, if k1 = 10 and k2 = 22, then your function should print 12, 20 and 22.\n
          20 \n
       /        \ \n
    8           22 \n
  /     \ \n
4       12 \n
</item>
<item name="code">
public class Solution {\n
\t    private TreeNode buildTree(int[] num, int start, int end) {\n
\t\t        if (start > end) {\n
\t\t\t            return null;\n
\t\t        }\n
\n
\t\t        TreeNode node = new TreeNode(num[(start + end) / 2]);\n
\t\t        node.left = buildTree(num, start, (start + end) / 2 - 1);\n
\t\t        node.right = buildTree(num, (start + end) / 2 + 1, end);\n
\t\t        return node;\n
\t    }\n
\n
\t    public TreeNode sortedArrayToBST(int[] num) {\n
\t\t        if (num == null) {\n
\t\t\t            return null;\n
\t\t        }\n
\t\t        return buildTree(num, 0, num.length - 1);\n
\t    }\n
}
</item>
</string-array>
<string-array name="convert_sorted_list_to_binary_search_tree_">
<item name="definition">
Given a singly linked list where elements are sorted in ascending order,
convert it to a height balanced BST.
</item>
<item name="code">
public class Solution {\n
\t    private ListNode current;\n
\n
\t    private int getListLength(ListNode head) {\n
\t\t        int size = 0;\n
\n
\t\t        while (head != null) {\n
\t\t\t            size++;\n
\t\t\t            head = head.next;\n
\t\t        }\n
\n
\t\t        return size;\n
\t    }\n
\n
\t    public TreeNode sortedListToBST(ListNode head) {\n
\t\t        int size;\n
\n
\t\t        current = head;\n
\t\t        size = getListLength(head);\n
\n
\t\t        return sortedListToBSTHelper(size);\n
\t    }\n
\n
\t    public TreeNode sortedListToBSTHelper(int size) {\n
\t\t        if (size &lt;= 0) {\n
\t\t\t            return null;\n
\t\t        }\n
\n
\t\t        TreeNode left = sortedListToBSTHelper(size / 2);\n
\t\t        TreeNode root = new TreeNode(current.val);\n
\t\t        current = current.next;\n
\t\t        TreeNode right = sortedListToBSTHelper(size - 1 - size / 2);\n
\n
\t\t        root.left = left;\n
\t\t        root.right = right;\n
\n
\t\t        return root;\n
\t    }\n
}
</item>
</string-array>
<string-array name="binary_search_tree_iterator_">
<item name="definition">
Design an iterator over a binary search tree with the following rules:
 - Elements are visited in ascending order (i.e. an in-order traversal)\n
 - next() and hasNext() queries run in O(1) time in average.\n
Example\n
For the following binary search tree, in-order traversal by using iterator is [1, 6, 10, 11, 12]\n
           10 \n
         /    \ \n
        1      11 \n
         \       \ \n
             6       12 \n
Challenge\n
Extra memory usage O(h), h is the height of the tree.\n
Super Star: Extra memory usage O(1)
</item>
<item name="code">
    /**\n
 * Definition of TreeNode:\n
 * public class TreeNode {\n
 *     public int val;\n
 *     public TreeNode left, right;\n
 *     public TreeNode(int val) {\n
 *         this.val = val;\n
 *         this.left = this.right = null;\n
 *     }\n
 * }\n
 * Example of iterate a tree:\n
 * Solution iterator = new Solution(root);\n
 * while (iterator.hasNext()) {\n
 *    TreeNode node = iterator.next();\n
 *    do something for node\n
 * }\n
 */\n
public class Solution {\n
\t    private Stack stack = new Stack&lt;&gt;();\n
\t    private TreeNode curt;\n
\n
\t    // @param root: The root of binary tree.\n
\t    public Solution(TreeNode root) {\n
\t\t        curt = root;\n
\t    }\n
\n
\t    //@return: True if there has next node, or false\n
\t    public boolean hasNext() {\n
\t\t        return (curt != null || !stack.isEmpty()); //important to judge curt != null\n
\t    }\n
\n
\t    //@return: return next node\n
\t    public TreeNode next() {\n
\t\t        while (curt != null) {\n
\t\t\t            stack.push(curt);\n
\t\t\t            curt = curt.left;\n
\t\t        }\n
\n
\t\t        curt = stack.pop();\n
\t\t        TreeNode node = curt;\n
\t\t        curt = curt.right;\n
\n
\t\t        return node;\n
\t    }\n
}
</item>
</string-array>

<string-array name="subsets_">
<item name="definition">
Given a set of distinct integers, return all possible subsets.\n
Note\n
Elements in a subset must be in non-descending order.
The solution set must not contain duplicate subsets.\n
Example\n
If S = [1,2,3], a solution is:\n
[\n
  [3],\n
  [1],\n
  [2],\n
  [1,2,3],\n
  [1,3],\n
  [2,3],\n
  [1,2],\n
  []\n
]
</item>
<item name="code">
    public class Solution {\n
\t    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subsets(int[] num) {\n
\t\t        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();\n
\t\t        if(num == null || num.length == 0) {\n
\t\t\t            return result;\n
\t\t        }\n
\t\t        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n
\t\t        Arrays.sort(num);\n
\t\t        subsetsHelper(result, list, num, 0);\n
\n
\t\t        return result;\n
\t    }\n
\n
\t    private void subsetsHelper(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result,\n
\t\t        ArrayList&lt;Integer&gt; list, int[] num, int pos) {\n
\n
\t\t        result.add(new ArrayList&lt;Integer&gt;(list));\n
\n
\t\t        for (int i = pos; i &lt; num.length; i++) {\n
\n
\t\t\t            list.add(num[i]);\n
\t\t\t            subsetsHelper(result, list, num, i + 1);\n
\t\t\t            list.remove(list.size() - 1);\n
\t\t        }\n
\t    }\n
}\n
\n
// Non Recursion\n
class Solution {\n
\t    /**\n
\t     * @param S: A set of numbers.\n
\t     * @return: A list of lists. All valid subsets.\n
\t     */\n
\t    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subsets(int[] nums) {\n
\t\t        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();\n
\t\t        int n = nums.length;\n
\t\t        Arrays.sort(nums);\n
\n
\t\t        // 1 &lt;&lt; n is 2^n\n
\t\t        // each subset equals to an binary integer between 0 .. 2^n - 1\n
\t\t        // 0 -&gt; 000 -&gt; []\n
\t\t        // 1 -&gt; 001 -&gt; [1]\n
\t\t        // 2 -&gt; 010 -&gt; [2]\n
\t\t        // ..\n
\t\t        // 7 -&gt; 111 -&gt; [1,2,3]\n
\t\t        for (int i = 0; i &lt; (1 &lt;&lt; n); i++) {\n
\t\t\t            ArrayList&lt;Integer&gt; subset = new ArrayList&lt;Integer&gt;();\n
\t\t\t            for (int j = 0; j &lt; n; j++) {\n
\t\t\t\t                // check whether the jth digit in i\'s binary representation is 1\n
\t\t\t\t                if ((i &amp; (1 &lt;&lt; j)) != 0) {\n
\t\t\t\t\t                    subset.add(nums[j]);\n
\t\t\t\t                }\n
\t\t\t            }\n
\t\t\t            result.add(subset);\n
\t\t        }\n
\t\t        return result;\n
\t    }\n
}
</item>
</string-array>
<string-array name="permutation_">
<item name="definition">
Given a list of numbers, return all possible permutations.\n
Example\n
For nums [1,2,3], the permutaions are:\n
[\n
    [1,2,3],\n
    [1,3,2],\n
    [2,1,3],\n
    [2,3,1],\n
    [3,1,2],\n
    [3,2,1]\n
]\n
Challenge\n
Do it without recursion
</item>
<item name="code">
public class Solution {\n
\t    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; permute(int[] num) {\n
\t\t         ArrayList&lt;ArrayList&lt;Integer&gt;&gt; rst = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();\n
\t\t         if (num == null || num.length == 0) {\n
\t\t\t             return rst;\n
\t\t         }\n
\n
\t\t         ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n
\t\t         helper(rst, list, num);\n
\t\t         return rst;\n
\t    }\n
\n
\t    public void helper(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; rst, ArrayList&lt;Integer&gt; list, int[] num){\n
\t\t        if(list.size() == num.length) {\n
\t\t\t            rst.add(new ArrayList&lt;Integer&gt;(list));\n
\t\t\t            return;\n
\t\t        }\n
\n
\t\t        for(int i = 0; i&lt;num.length; i++){\n
\t\t\t            if(list.contains(num[i])){\n
\t\t\t\t                continue;\n
\t\t\t            }\n
\t\t\t            list.add(num[i]);\n
 \t\t\t           helper(rst, list, num);\n
 \t\t\t           list.remove(list.size() - 1);\n
\t\t        }\n
\t    }\n
}\n
// Non-Recursion\n
class Solution {\n
\t    /**\n
\t     * @param nums: A list of integers.\n
\t     * @return: A list of permutations.\n
\t     */\n
\t    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; permute(ArrayList&lt;Integer&gt; nums) {\n
\t\t        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; permutations\n
\t\t             = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();\n
\t\t        if (nums == null || nums.size() == 0) {\n
\t\t\t            return permutations;\n
\t\t        }\n
\n
\t\t        int n = nums.size();\n
\t\t        ArrayList&lt;Integer&gt; stack = new ArrayList&lt;Integer&gt;();\n
\n
\t\t        stack.add(-1);\n
\t\t        while (stack.size() != 0) {\n
\t\t\t            Integer last = stack.get(stack.size() - 1);\n
\t\t\t            stack.remove(stack.size() - 1);\n
\n
\t\t            // increase the last number\n
\t\t            int next = -1;\n
\t\t            for (int i = last + 1; i &lt; n; i++) {\n
\t\t\t                if (!stack.contains(i)) {\n
\t\t\t\t                    next = i;\n
\t\t\t\t                    break;\n
\t\t\t                }\n
\t\t            }\n
\t\t            if (next == -1) {\n
\t\t\t                continue;\n
\t\t            }\n
\n
\t\t            // generate the next permutation\n
\t\t            stack.add(next);\n
\t\t            for (int i = 0; i &lt; n; i++) {\n
\t\t\t                if (!stack.contains(i)) {\n
\t\t\t\t                    stack.add(i);\n
\t\t\t                }\n
\t\t            }\n
\n
\t\t            // copy to permutations set\n
\t\t            ArrayList&lt;Integer&gt; permutation = new ArrayList&lt;Integer&gt;();\n
\t\t            for (int i = 0; i &lt; n; i++) {\n
\t\t\t                permutation.add(nums.get(stack.get(i)));\n
\t\t            }\n
\t\t            permutations.add(permutation);\n
\t\t        }\n
\t\t        return permutations;\n
\t    }\n
}
</item>
</string-array>

<string-array name="triangle_">
<item name="definition">
        Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.
\n
        Note\n
        Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.
\n
        Example\n
        For example, given the following triangle
\n
        [\n
        [2],\n
        [3,4],\n
        [6,5,7],\n
        [4,1,8,3]\n
        ]\n
        The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).
</item>
<item name="code">
    // version 0: top-down\n
public class Solution {\n
\t    /**\n
\t     * @param triangle: a list of lists of integers.\n
\t     * @return: An integer, minimum path sum.\n
\t     */\n
\t    public int minimumTotal(int[][] triangle) {\n
\t\t        if (triangle == null || triangle.length == 0) {\n
\t\t\t            return -1;\n
 \t\t       }\n
\t\t        if (triangle[0] == null || triangle[0].length == 0) {\n
\t\t\t            return -1;\n
\t\t        }\n
\n
\t\t        // state: f[x][y] = minimum path value from 0,0 to x,y\n
\t\t        int n = triangle.length;\n
\t\t        int[][] f = new int[n][n];\n
\n
\t\t        // initialize\n
\t\t        f[0][0] = triangle[0][0];\n
\t\t        for (int i = 1; i &lt; n; i++) {\n
\t\t\t            f[i][0] = f[i - 1][0] + triangle[i][0];\n
\t\t\t            f[i][i] = f[i - 1][i - 1] + triangle[i][i];\n
\t\t        }\n
\n
\t\t        // top down\n
\t\t        for (int i = 1; i &lt; n; i++) {\n
\t\t\t            for (int j = 1; j &lt; i; j++) {\n
\t\t\t\t                f[i][j] = Math.min(f[i - 1][j], f[i - 1][j - 1]) + triangle[i][j];\n
\t\t\t            }\n
\t\t        }\n
\n
\t\t        // answer\n
\t\t        int best = f[n - 1][0];\n
\t\t        for (int i = 1; i &lt; n; i++) {\n
\t\t\t            best = Math.min(best, f[n - 1][i]);\n
\t\t        }\n
\t\t        return best;\n
\t    }\n
}\n
\n
//Version 1: Bottom-Up\n
public class Solution {\n
\t    /**\n
\t     * @param triangle: a list of lists of integers.\n
\t     * @return: An integer, minimum path sum.\n
\t     */\n
\t    public int minimumTotal(int[][] triangle) {\n
\t\t        if (triangle == null || triangle.length == 0) {\n
 \t\t\t           return -1;\n
\t\t        }\n
\t\t        if (triangle[0] == null || triangle[0].length == 0) {\n
\t\t\t            return -1;\n
\t\t        }\n
\t\t        // state: f[x][y] = minimum path value from x,y to bottom\n
\t\t        int n = triangle.length;\n
\t\t        int[][] f = new int[n][n];\n
\n
\t\t        // initialize\n
\t\t        for (int i = 0; i &lt; n; i++) {\n
\t\t\t            f[n - 1][i] = triangle[n - 1][i];\n
\t\t        }\n
\t\t        // bottom up\n
\t\t        for (int i = n - 2; i &gt;= 0; i--) {\n
\t\t\t            for (int j = 0; j &lt;= i; j++) {\n
\t\t\t\t                f[i][j] = Math.min(f[i + 1][j], f[i + 1][j + 1]) + triangle[i][j];\n
\t\t\t            }\n
\t\t        }\n
\t\t        // answer\n
\t\t        return f[0][0];\n
\t    }\n
}\n
//Version 2 : Memorize Search\n
public class Solution {\n
\t    private int n;\n
\t    private int[][] minSum;\n
\t    private int[][] triangle;\n
\n
\t    private int search(int x, int y) {\n
\t\t        if (x &gt;= n) {\n
\t\t\t            return 0;\n
\t\t        }\n
\n
\t\t        if (minSum[x][y] != Integer.MAX_VALUE) {\n
\t\t\t            return minSum[x][y];\n
\t\t        }\n
\n
\t\t        minSum[x][y] = Math.min(search(x + 1, y), search(x + 1, y + 1))\n
\t\t            + triangle[x][y];\n
\t\t        return minSum[x][y];\n
\t    }\n
\n
\t    public int minimumTotal(int[][] triangle) {\n
\t\t        if (triangle == null || triangle.length == 0) {\n
\t\t\t            return -1;\n
\t\t        }\n
\t\t        if (triangle[0] == null || triangle[0].length == 0) {\n
\t\t\t            return -1;\n
\t\t        }\n
\n
\t\t        this.n = triangle.length;\n
\t\t        this.triangle = triangle;\n
\t\t        this.minSum = new int[n][n];\n
\n
\t\t        for (int i = 0; i &lt; n; i++) {\n
\t\t\t            for (int j = 0; j &lt; n; j++) {\n
\t\t\t\t                minSum[i][j] = Integer.MAX_VALUE;\n
\t\t\t            }\n
\t\t        }\n
\t\t        return search(0, 0);\n
\t    }\n
}\n
</item>
</string-array>
<string-array name="backpack_">
<item name="definition">
Given n items with size A[i], an integer m denotes the size of a backpack. How full you can fill this backpack?
\n
Note\n
You can not divide any item into small pieces.
\n
Example\n
If we have 4 items with size [2, 3, 5, 7], the backpack size is 11, we can select 2, 3 and 5, so that the max size we can fill this backpack is 10. If the backpack size is 12. we can select [2, 3, 7] so that we can fulfill the backpack.
\n
You function should return the max size we can fill in the given backpack.
</item>
<item name="code">
public class Solution {\n
\t    /**\n
\t     * @param m: An integer m denotes the size of a backpack\n
\t     * @param A: Given n items with size A[i]\n
\t     * @return: The maximum size\n
\t     */\n
\t    public int backPack(int m, int[] A) {\n
\t\t        boolean f[][] = new boolean[A.length + 1][m + 1];\n
\t\t        for (int i = 0; i &lt;= A.length; i++) {\n
\t\t\t            fo\tr (int j = 0; j &lt;= m; j++) {\n
\t\t\t\t                f[i][j] = false;\n
\t\t\t            }\n
\t\t        }\n
\t\t        f[0][0] = true;\n
\t\t        for (int i = 0; i &lt; A.length; i++) {\n
\t\t\t            fo\tr (int j = 0; j &lt;= m; j++) {\n
 \t\t\t\t               f[i + 1][j] = f[i][j];\n
 \t\t\t\t               if (j &gt;= A[i] &amp;&amp; f[i][j - A[i]]) {\n
 \t\t\t\t\t                   f[i + 1][j] = true;\n
 \t\t\t\t               }\n
 \t\t\t           } // for j\n
\t\t        } // for i\n
\n
 \t\t       for (int i = m; i &gt;= 0; i--) {\n
 \t\t\t           if (f\t[A.length][i]) {\n
 \t\t\t\t               return i;\n
 \t\t\t           }\n
 \t\t       }\n
 \t\t       return 0;\n
 \t   }\n
}\n
</item>
</string-array>
<string-array name="minimum_path_sum_">
<item name="definition">
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
\n
Note\n
You can only move either down or right at any point in time.
</item>
<item name="code">
    public class Solution {\n
\t    public int minPathSum(int[][] grid) {\n
\t\t        if (grid == null || grid.length == 0 || grid[0].length == 0) {\n
\t\t\t            return 0;\n
\t\t        }\n
\n
\t\t        int M = \tgrid.length;\n
\t\t        int N = grid[0].length;\n
\t\t        int[][] sum = new int[M][N];\n
\n
\t\t        sum[0][0] = grid[0][0];\n
\n
\t\t        for (int i = 1; i &lt; M; i++) {\n
\t\t\t            sum[i][0] = sum[i - 1][0] + grid[i][0];\n
\t\t        }\n
\n
\t\t        for (int i = 1; i &lt; N; i++) {\n
\t\t\t            sum[0][i] = sum[0][i - 1] + grid[0][i];\n
\t\t        }\n
\n
\t\t        for (int i = 1; i &lt; M; i++) {\n
\t\t\t            for (int j = 1; j &lt; N; j++) {\n
\t\t\t\t                sum[i][j] = Math.min(sum[i - 1][j], sum[i][j - 1]) + grid[i][j];\n
 \t\t\t           }\n
\t\t        }\n
\n
\t\t        return sum[M - 1][N - 1];\n
\t    }\n
}\n
</item>
</string-array>
<string-array name="unique_paths_">
<item name="definition">
A robot is located at the top-left corner of a m x n grid (marked \'Start\' in the diagram below).
\n
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked \'Finish\' in the diagram below).
\n
How many possible unique paths are there?
\n
Note\n
m and n will be at most 100.
</item>
<item name="code">
public class Solution {\n
\t    public int uniquePaths(int m, int n) {\n
\t\t        if (m == 0 || n == 0) {\n
\t\t\t            return 0;\n
\t\t        }\n
\t\t        int[][] sum = new int[m][n];\n
\t\t        for (int i = 0; i &lt; m; i++) {\n
\t\t\t            sum[i][0] = 1;\n
\t\t        }\n
\t\t        for (int i = 0; i &lt; n; i++) {\n
\t\t\t            sum[0][i] = 1;\n
\t\t        }\n
\t\t        for (int i = 1; i &lt; m; i++) {\n
\t\t\t            for (int j = 1; j &lt; n; j++) {\n
\t\t\t\t                sum[i][j] = sum[i - 1][j] + sum[i][j - 1];\n
\t\t\t            }\n
\t\t        }\n
\t\t        return sum[m - 1][n - 1];\n
\t    }\n
}
</item>
</string-array>
<string-array name="climbing_stairs_">
<item name="definition">
You are climbing a stair case. It takes n steps to reach to the top.
\n
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
\n
Example\n
Given an example n=3 , 1+1+1=2+1=1+2=3
\n
return 3
</item>
<item name="code">
public class Solution {\n
\t    public int climbStairs(int n) {\n
\t\t        if (n &lt;= 1) {\n
\t\t\t            return 1;\n
\t\t        }\n
\t\t        int last = 1, lastlast = 1;\n
\t\t        int now = 0;\n
\t\t        for (int i = 2; i &lt;= n; i++) {\n
\t\t\t            now = last + lastlast;\n
\t\t\t            lastlast = last;\n
\t\t\t            last = now;\n
\t\t        }\n
\t\t        return now;\n
    \t   }\n
}
</item>
</string-array>

<string-array name="jump_game_">
<item name="definition">
Given an array of non-negative integers, you are initially positioned at the first index of the array.
\n
Each element in the array represents your maximum jump length at that position.
\n
Determine if you are able to reach the last index.
\n
Example\n
A = [2,3,1,1,4], return true.
\n
A = [3,2,1,0,4], return false.
</item>
<item name="code">
// version 1: Dynamic Programming\n
public class Solution {\n
\t    public boolean canJump(int[] A) {\n
\t\t        boolean[] can = new boolean[A.length];\n
\t\t        can[0] = true;\n
\n
\t\t        for (int i = 1; i &lt; A.length; i++) {\n
 \t\t\t           for (int j = 0; j &lt; i; j++) {\n
 \t\t\t\t               if (can[j] &amp;&amp; j + A[j] &gt;= i) {\n
\t\t\t\t\t                    can[i] = true;\n
\t\t\t\t\t                    break;\n
\t\t\t\t                }\n
 \t\t\t           }\n
 \t\t       }\n
\n
\t\t        return can[A.length - 1];\n
\t    }\n
}\n
    \n
// version 2: Greedy\n
public class Solution {\n
\t    public boolean canJump(int[] A) {\n
\t\t        // think it as merging n intervals\n
\t\t        if (A == null || A.length == 0) {\n
\t\t\t            return false;\n
\t\t        }\n
\t\t        int farthest = A[0];\n
\t\t        for (int i = 1; i &lt; A.length; i++) {\n
\t\t\t            if (i &lt;= farthest &amp;&amp; A[i] + i &gt;= farthest) {\n
\t\t\t\t                farthest = A[i] + i;\n
\t\t\t            }\n
\t\t        }\n
\t\t        return farthest &gt;= A.length - 1;\n
\t    }\n
}\n
</item>
</string-array>

</resources>
